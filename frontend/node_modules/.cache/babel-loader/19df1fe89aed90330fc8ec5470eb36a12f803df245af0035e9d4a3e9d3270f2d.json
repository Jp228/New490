{"ast":null,"code":"(function (root, factory) {\n  /* istanbul ignore next */\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['exports'], factory);\n  } /* istanbul ignore else */else if (typeof exports === 'object') {\n    // CommonJS\n    factory(exports);\n  } else {\n    // Browser globals\n    factory(root.promiseBreaker = {});\n  }\n})(this, function (exports) {\n  /* istanbul ignore next */\n  var globals = global || window;\n\n  /* Returns an array of `count` unique identifiers. */\n  function makeParams(count) {\n    var answer = [];\n    for (var i = 0; i < count; i++) {\n      answer.push('p' + i);\n    }\n    return answer;\n  }\n\n  /* Converts an array of parameter names into a comma delimited list. */\n  function toList(params, extraParam, appendComma) {\n    if (extraParam) {\n      params = params.concat([extraParam]);\n    }\n    return params.join(', ') + (appendComma && params.length ? ',' : '');\n  }\n\n  /* Returns true if `fn` is a function/ */\n  function isFunction(fn) {\n    var str = Object.prototype.toString.call(fn);\n    return !!fn && (typeof fn === 'object' || typeof fn === 'function') && (str === '[object Function]' || str === '[object AsyncFunction]');\n  }\n  function validatePromise(p) {\n    if (!p) {\n      throw new Error('Promise is undefined. Define Promise as global variable or call withPromise()');\n    }\n    if (!isFunction(p)) {\n      throw new Error('Expect Promise to be a constructor');\n    }\n  }\n\n  /* Note if `promiseImpl` is `null`, this will use globals.Promise. */\n  exports.withPromise = function (promiseImpl) {\n    // If a promise implementation is provided, we can validate it right away, and fail\n    // earlier.  If not, we can't validate globals.Promise, since globals.Promise might\n    // get polyfilled after promise-breaker is initialized.\n    if (promiseImpl) {\n      validatePromise(promiseImpl);\n    }\n    var pb = {};\n    pb.make = function (options, asyncFn) {\n      if (!asyncFn) {\n        asyncFn = options;\n        options = {};\n      }\n      if (!isFunction(asyncFn)) {\n        throw new Error('Function required');\n      }\n      if (!promiseImpl) {\n        validatePromise(globals.Promise);\n      }\n      var argumentCount = options.args || asyncFn.length;\n      var args = makeParams(argumentCount - 1);\n      var fn = new Function(['asyncFn', 'Promise'], 'return function(' + toList(args, 'done') + ') {\\n' + '    if(done) {\\n' + '        return asyncFn.call(this, ' + toList(args, 'done') + ');\\n' + '    } else {\\n' + '        var _this = this;\\n' + '        return new Promise(function(resolve, reject) {\\n' + '            asyncFn.call(_this, ' + toList(args, null, true) + ' function(err, result) {\\n' + '                if(err) {\\n' + '                    reject(err);\\n' + '                } else {\\n' +\n      // If multiple arguments were passed to the callback, then turn them into an array.\n      '                    if(arguments.length > 2) {' + '                        resolve([].slice.call(arguments, 1));' + '                    } else {' + '                        resolve(result);\\n' + '                    }' + '                }\\n' + '            });\\n' + '        });\\n' + '    }\\n' + '};');\n      return fn(asyncFn, promiseImpl || globals.Promise);\n    };\n    pb['break'] = function (options, promiseFn) {\n      if (!promiseFn) {\n        promiseFn = options;\n        options = {};\n      }\n      if (!isFunction(promiseFn)) {\n        throw new Error('Function required');\n      }\n      var argumentCount = options.args || promiseFn.length;\n      var args = makeParams(argumentCount);\n      var params = ['this'].concat(args);\n      var fn = new Function(['promiseFn'], 'return function(' + toList(args, 'done') + ') {\\n' + '    if(done) {\\n' +\n      // Call `done()` inside `setTimeout()`, so that if `done` throws an error, it will\n      // be turned into an uncaught exception, instead of being swallowed by the Promise.\n      '        promiseFn.call(' + toList(params) + ').then(\\n' + '            function(result) {setTimeout(function() {done(null, result);}, 0);},\\n' + '            function(err) {setTimeout(function() {done(err);}, 0);}\\n' + '        );\\n' + '        return null;\\n' + '    } else {\\n' + '        return promiseFn.call(' + toList(params) + ');\\n' + '    }\\n' + '};');\n      return fn(promiseFn);\n    };\n    pb.addPromise = function (done, fn) {\n      var answer = null;\n      if (done) {\n        fn(done);\n      } else {\n        answer = new Promise(function (resolve, reject) {\n          fn(function (err, result) {\n            if (err) {\n              reject(err);\n            } else if (arguments.length > 2) {\n              // If multiple arguments were passed to the callback, then turn them into an array.\n              resolve([].slice.call(arguments, 1));\n            } else {\n              resolve(result);\n            }\n          });\n        });\n      }\n      return answer;\n    };\n    pb.addCallback = function (done, promise) {\n      var answer;\n      if (!promise) {\n        throw new Error('addCallback() expected promise or function as second paramater');\n      } else if (isFunction(promise.then)) {\n        answer = promise;\n      } else if (isFunction(promise)) {\n        answer = Promise.resolve().then(function () {\n          return promise();\n        });\n      } else {\n        throw new Error(\"addCallback() don't know what to do with \" + typeof promise);\n      }\n      if (done) {\n        // Call `done()` inside `setTimeout()`, so that if `done` throws an error, it will\n        // be turned into an uncaught exception, instead of being swallowed by the Promise.\n        answer.then(function (result) {\n          setTimeout(function () {\n            done(null, result);\n          }, 0);\n        }, function (err) {\n          setTimeout(function () {\n            done(err);\n          }, 0);\n        });\n        answer = null;\n      }\n      return answer;\n    };\n    pb.applyFn = function (fn, argumentCount, thisArg, args, done) {\n      argumentCount = argumentCount || 0;\n      args = args || [];\n      if (fn.length > argumentCount + 1) {\n        return pb.addCallback(done, Promise.reject(new Error('Expected function with ' + argumentCount + ' or fewer arguments which returns Promise, ' + 'or function with ' + (argumentCount + 1) + ' arguments which takes callback - got function with ' + fn.length + ' arguments.')));\n      }\n      return pb.addCallback(done, Promise.resolve().then(function () {\n        var isCallbackFn = argumentCount < fn.length;\n        var donePromise;\n        if (args.length < argumentCount || isCallbackFn) {\n          // Clone args\n          args = args.slice(0);\n\n          // Fill with undefineds.\n          while (args.length < argumentCount) {\n            args.push(undefined);\n          }\n\n          // Add a callback to `args` if required.\n          if (isCallbackFn) {\n            donePromise = new (promiseImpl || globals.Promise)(function (resolve, reject) {\n              // Pass in a callback.\n              args[argumentCount] = function (err, result) {\n                if (err) {\n                  reject(err);\n                } else {\n                  resolve(result);\n                }\n              };\n            });\n          }\n        }\n        var returnedPromise = fn.apply(thisArg, args);\n        return donePromise || returnedPromise;\n      }));\n    };\n    pb.apply = function (fn, thisArg, args, done) {\n      args = args || [];\n      return pb.applyFn(fn, args.length, thisArg, args, done);\n    };\n    pb.callFn = function (fn, argumentCount, thisArg) {\n      argumentCount = argumentCount || 0;\n      var maxArgumentsToFetch = Math.min(arguments.length - 3, argumentCount);\n      var args = [];\n      if (maxArgumentsToFetch > 0) {\n        args = [].slice.call(arguments, 3, 3 + maxArgumentsToFetch);\n      }\n\n      // Fetch `done` if it's there.\n      var done = arguments[3 + argumentCount];\n      return pb.applyFn(fn, argumentCount, thisArg, args, done);\n    };\n    pb.call = function (fn, thisArg) {\n      var args = [].slice.call(arguments, 2);\n      return pb.applyFn(fn, args.length, thisArg, args);\n    };\n    pb.callWithCb = function (fn, thisArg) {\n      var args = [].slice.call(arguments, 2, arguments.length - 1);\n      var done = arguments[arguments.length - 1];\n      if (!isFunction(done)) {\n        throw new Error('callWithCb requires function as last parameter.');\n      }\n      return pb.applyFn(fn, args.length, thisArg, args, done);\n    };\n    return pb;\n  };\n  exports.default = exports.withPromise();\n  for (var k in exports.default) {\n    /* istanbul ignore else */\n    if ({}.hasOwnProperty.call(exports.default, k)) {\n      exports[k] = exports.default[k];\n    }\n  }\n  exports.usingDefaultPromise = exports.default;\n});","map":{"version":3,"names":["root","factory","define","amd","exports","promiseBreaker","globals","global","window","makeParams","count","answer","i","push","toList","params","extraParam","appendComma","concat","join","length","isFunction","fn","str","Object","prototype","toString","call","validatePromise","p","Error","withPromise","promiseImpl","pb","make","options","asyncFn","Promise","argumentCount","args","Function","promiseFn","addPromise","done","resolve","reject","err","result","arguments","slice","addCallback","promise","then","setTimeout","applyFn","thisArg","isCallbackFn","donePromise","undefined","returnedPromise","apply","callFn","maxArgumentsToFetch","Math","min","callWithCb","default","k","hasOwnProperty","usingDefaultPromise"],"sources":["/home/jp228/node_modules/promise-breaker/index.js"],"sourcesContent":["(function (root, factory) {\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports'], factory);\n    } /* istanbul ignore else */ else if (typeof exports === 'object') {\n        // CommonJS\n        factory(exports);\n    } else {\n        // Browser globals\n        factory((root.promiseBreaker = {}));\n    }\n})(this, function (exports) {\n    /* istanbul ignore next */\n    var globals = global || window;\n\n    /* Returns an array of `count` unique identifiers. */\n    function makeParams(count) {\n        var answer = [];\n        for (var i = 0; i < count; i++) {\n            answer.push('p' + i);\n        }\n        return answer;\n    }\n\n    /* Converts an array of parameter names into a comma delimited list. */\n    function toList(params, extraParam, appendComma) {\n        if (extraParam) {\n            params = params.concat([extraParam]);\n        }\n        return params.join(', ') + (appendComma && params.length ? ',' : '');\n    }\n\n    /* Returns true if `fn` is a function/ */\n    function isFunction(fn) {\n        var str = Object.prototype.toString.call(fn);\n        return (\n            !!fn &&\n            (typeof fn === 'object' || typeof fn === 'function') &&\n            (str === '[object Function]' || str === '[object AsyncFunction]')\n        );\n    }\n\n    function validatePromise(p) {\n        if (!p) {\n            throw new Error(\n                'Promise is undefined. Define Promise as global variable or call withPromise()'\n            );\n        }\n        if (!isFunction(p)) {\n            throw new Error('Expect Promise to be a constructor');\n        }\n    }\n\n    /* Note if `promiseImpl` is `null`, this will use globals.Promise. */\n    exports.withPromise = function (promiseImpl) {\n        // If a promise implementation is provided, we can validate it right away, and fail\n        // earlier.  If not, we can't validate globals.Promise, since globals.Promise might\n        // get polyfilled after promise-breaker is initialized.\n        if (promiseImpl) {\n            validatePromise(promiseImpl);\n        }\n\n        var pb = {};\n\n        pb.make = function (options, asyncFn) {\n            if (!asyncFn) {\n                asyncFn = options;\n                options = {};\n            }\n\n            if (!isFunction(asyncFn)) {\n                throw new Error('Function required');\n            }\n            if (!promiseImpl) {\n                validatePromise(globals.Promise);\n            }\n\n            var argumentCount = options.args || asyncFn.length;\n            var args = makeParams(argumentCount - 1);\n\n            var fn = new Function(\n                ['asyncFn', 'Promise'],\n                'return function(' +\n                    toList(args, 'done') +\n                    ') {\\n' +\n                    '    if(done) {\\n' +\n                    '        return asyncFn.call(this, ' +\n                    toList(args, 'done') +\n                    ');\\n' +\n                    '    } else {\\n' +\n                    '        var _this = this;\\n' +\n                    '        return new Promise(function(resolve, reject) {\\n' +\n                    '            asyncFn.call(_this, ' +\n                    toList(args, null, true) +\n                    ' function(err, result) {\\n' +\n                    '                if(err) {\\n' +\n                    '                    reject(err);\\n' +\n                    '                } else {\\n' +\n                    // If multiple arguments were passed to the callback, then turn them into an array.\n                    '                    if(arguments.length > 2) {' +\n                    '                        resolve([].slice.call(arguments, 1));' +\n                    '                    } else {' +\n                    '                        resolve(result);\\n' +\n                    '                    }' +\n                    '                }\\n' +\n                    '            });\\n' +\n                    '        });\\n' +\n                    '    }\\n' +\n                    '};'\n            );\n            return fn(asyncFn, promiseImpl || globals.Promise);\n        };\n\n        pb['break'] = function (options, promiseFn) {\n            if (!promiseFn) {\n                promiseFn = options;\n                options = {};\n            }\n\n            if (!isFunction(promiseFn)) {\n                throw new Error('Function required');\n            }\n\n            var argumentCount = options.args || promiseFn.length;\n            var args = makeParams(argumentCount);\n            var params = ['this'].concat(args);\n\n            var fn = new Function(\n                ['promiseFn'],\n                'return function(' +\n                    toList(args, 'done') +\n                    ') {\\n' +\n                    '    if(done) {\\n' +\n                    // Call `done()` inside `setTimeout()`, so that if `done` throws an error, it will\n                    // be turned into an uncaught exception, instead of being swallowed by the Promise.\n                    '        promiseFn.call(' +\n                    toList(params) +\n                    ').then(\\n' +\n                    '            function(result) {setTimeout(function() {done(null, result);}, 0);},\\n' +\n                    '            function(err) {setTimeout(function() {done(err);}, 0);}\\n' +\n                    '        );\\n' +\n                    '        return null;\\n' +\n                    '    } else {\\n' +\n                    '        return promiseFn.call(' +\n                    toList(params) +\n                    ');\\n' +\n                    '    }\\n' +\n                    '};'\n            );\n            return fn(promiseFn);\n        };\n\n        pb.addPromise = function (done, fn) {\n            var answer = null;\n            if (done) {\n                fn(done);\n            } else {\n                answer = new Promise(function (resolve, reject) {\n                    fn(function (err, result) {\n                        if (err) {\n                            reject(err);\n                        } else if (arguments.length > 2) {\n                            // If multiple arguments were passed to the callback, then turn them into an array.\n                            resolve([].slice.call(arguments, 1));\n                        } else {\n                            resolve(result);\n                        }\n                    });\n                });\n            }\n            return answer;\n        };\n\n        pb.addCallback = function (done, promise) {\n            var answer;\n            if (!promise) {\n                throw new Error('addCallback() expected promise or function as second paramater');\n            } else if (isFunction(promise.then)) {\n                answer = promise;\n            } else if (isFunction(promise)) {\n                answer = Promise.resolve().then(function () {\n                    return promise();\n                });\n            } else {\n                throw new Error(\"addCallback() don't know what to do with \" + typeof promise);\n            }\n\n            if (done) {\n                // Call `done()` inside `setTimeout()`, so that if `done` throws an error, it will\n                // be turned into an uncaught exception, instead of being swallowed by the Promise.\n                answer.then(\n                    function (result) {\n                        setTimeout(function () {\n                            done(null, result);\n                        }, 0);\n                    },\n                    function (err) {\n                        setTimeout(function () {\n                            done(err);\n                        }, 0);\n                    }\n                );\n                answer = null;\n            }\n\n            return answer;\n        };\n\n        pb.applyFn = function (fn, argumentCount, thisArg, args, done) {\n            argumentCount = argumentCount || 0;\n            args = args || [];\n\n            if (fn.length > argumentCount + 1) {\n                return pb.addCallback(\n                    done,\n                    Promise.reject(\n                        new Error(\n                            'Expected function with ' +\n                                argumentCount +\n                                ' or fewer arguments which returns Promise, ' +\n                                'or function with ' +\n                                (argumentCount + 1) +\n                                ' arguments which takes callback - got function with ' +\n                                fn.length +\n                                ' arguments.'\n                        )\n                    )\n                );\n            }\n\n            return pb.addCallback(\n                done,\n                Promise.resolve().then(function () {\n                    var isCallbackFn = argumentCount < fn.length;\n                    var donePromise;\n\n                    if (args.length < argumentCount || isCallbackFn) {\n                        // Clone args\n                        args = args.slice(0);\n\n                        // Fill with undefineds.\n                        while (args.length < argumentCount) {\n                            args.push(undefined);\n                        }\n\n                        // Add a callback to `args` if required.\n                        if (isCallbackFn) {\n                            donePromise = new (promiseImpl || globals.Promise)(function (\n                                resolve,\n                                reject\n                            ) {\n                                // Pass in a callback.\n                                args[argumentCount] = function (err, result) {\n                                    if (err) {\n                                        reject(err);\n                                    } else {\n                                        resolve(result);\n                                    }\n                                };\n                            });\n                        }\n                    }\n\n                    var returnedPromise = fn.apply(thisArg, args);\n                    return donePromise || returnedPromise;\n                })\n            );\n        };\n\n        pb.apply = function (fn, thisArg, args, done) {\n            args = args || [];\n            return pb.applyFn(fn, args.length, thisArg, args, done);\n        };\n\n        pb.callFn = function (fn, argumentCount, thisArg) {\n            argumentCount = argumentCount || 0;\n\n            var maxArgumentsToFetch = Math.min(arguments.length - 3, argumentCount);\n            var args = [];\n            if (maxArgumentsToFetch > 0) {\n                args = [].slice.call(arguments, 3, 3 + maxArgumentsToFetch);\n            }\n\n            // Fetch `done` if it's there.\n            var done = arguments[3 + argumentCount];\n\n            return pb.applyFn(fn, argumentCount, thisArg, args, done);\n        };\n\n        pb.call = function (fn, thisArg) {\n            var args = [].slice.call(arguments, 2);\n            return pb.applyFn(fn, args.length, thisArg, args);\n        };\n\n        pb.callWithCb = function (fn, thisArg) {\n            var args = [].slice.call(arguments, 2, arguments.length - 1);\n            var done = arguments[arguments.length - 1];\n            if (!isFunction(done)) {\n                throw new Error('callWithCb requires function as last parameter.');\n            }\n            return pb.applyFn(fn, args.length, thisArg, args, done);\n        };\n\n        return pb;\n    };\n\n    exports.default = exports.withPromise();\n    for (var k in exports.default) {\n        /* istanbul ignore else */\n        if ({}.hasOwnProperty.call(exports.default, k)) {\n            exports[k] = exports.default[k];\n        }\n    }\n\n    exports.usingDefaultPromise = exports.default;\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}