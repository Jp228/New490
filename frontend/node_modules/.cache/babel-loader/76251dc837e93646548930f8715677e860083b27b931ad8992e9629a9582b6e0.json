{"ast":null,"code":"//\n//\n//\n\n// Channel machinery.\n\n'use strict';\n\nvar defs = require('./defs');\nvar closeMsg = require('./format').closeMessage;\nvar inspect = require('./format').inspect;\nvar methodName = require('./format').methodName;\nvar assert = require('assert');\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\nvar fmt = require('util').format;\nvar IllegalOperationError = require('./error').IllegalOperationError;\nvar stackCapture = require('./error').stackCapture;\nfunction Channel(connection) {\n  EventEmitter.call(this);\n  this.connection = connection;\n  // for the presently outstanding RPC\n  this.reply = null;\n  // for the RPCs awaiting action\n  this.pending = [];\n  // for unconfirmed messages\n  this.lwm = 1; // the least, unconfirmed deliveryTag\n  this.unconfirmed = []; // rolling window of delivery callbacks\n  this.on('ack', this.handleConfirm.bind(this, function (cb) {\n    if (cb) cb(null);\n  }));\n  this.on('nack', this.handleConfirm.bind(this, function (cb) {\n    if (cb) cb(new Error('message nacked'));\n  }));\n  this.on('close', function () {\n    var cb;\n    while (cb = this.unconfirmed.shift()) {\n      if (cb) cb(new Error('channel closed'));\n    }\n  });\n  // message frame state machine\n  this.handleMessage = acceptDeliveryOrReturn;\n}\ninherits(Channel, EventEmitter);\nmodule.exports.Channel = Channel;\nmodule.exports.acceptMessage = acceptMessage;\nvar C = Channel.prototype;\nC.allocate = function () {\n  this.ch = this.connection.freshChannel(this);\n  return this;\n};\n\n// Incoming frames are either notifications of e.g., message delivery,\n// or replies to something we've sent. In general I deal with the\n// former by emitting an event, and with the latter by keeping a track\n// of what's expecting a reply.\n//\n// The AMQP specification implies that RPCs can't be pipelined; that\n// is, you can have only one outstanding RPC on a channel at a\n// time. Certainly that's what RabbitMQ and its clients assume. For\n// this reason, I buffer RPCs if the channel is already waiting for a\n// reply.\n\n// Just send the damn frame.\nC.sendImmediately = function (method, fields) {\n  return this.connection.sendMethod(this.ch, method, fields);\n};\n\n// Invariant: !this.reply -> pending.length == 0. That is, whenever we\n// clear a reply, we must send another RPC (and thereby fill\n// this.reply) if there is one waiting. The invariant relevant here\n// and in `accept`.\nC.sendOrEnqueue = function (method, fields, reply) {\n  if (!this.reply) {\n    // if no reply waiting, we can go\n    assert(this.pending.length === 0);\n    this.reply = reply;\n    this.sendImmediately(method, fields);\n  } else {\n    this.pending.push({\n      method: method,\n      fields: fields,\n      reply: reply\n    });\n  }\n};\nC.sendMessage = function (fields, properties, content) {\n  return this.connection.sendMessage(this.ch, defs.BasicPublish, fields, defs.BasicProperties, properties, content);\n};\n\n// Internal, synchronously resolved RPC; the return value is resolved\n// with the whole frame.\nC._rpc = function (method, fields, expect, cb) {\n  var self = this;\n  function reply(err, f) {\n    if (err === null) {\n      if (f.id === expect) {\n        return cb(null, f);\n      } else {\n        // We have detected a problem, so it's up to us to close the\n        // channel\n        var expectedName = methodName(expect);\n        var e = new Error(fmt(\"Expected %s; got %s\", expectedName, inspect(f, false)));\n        self.closeWithError(f.id, fmt('Expected %s; got %s', expectedName, methodName(f.id)), defs.constants.UNEXPECTED_FRAME, e);\n        return cb(e);\n      }\n    }\n    // An error will be given if, for example, this is waiting to be\n    // sent and the connection closes\n    else if (err instanceof Error) return cb(err);\n    // A close frame will be given if this is the RPC awaiting reply\n    // and the channel is closed by the server\n    else {\n      // otherwise, it's a close frame\n      var closeReason = (err.fields.classId << 16) + err.fields.methodId;\n      var e = method === closeReason ? fmt(\"Operation failed: %s; %s\", methodName(method), closeMsg(err)) : fmt(\"Channel closed by server: %s\", closeMsg(err));\n      var closeFrameError = new Error(e);\n      closeFrameError.code = err.fields.replyCode;\n      closeFrameError.classId = err.fields.classId;\n      closeFrameError.methodId = err.fields.methodId;\n      return cb(closeFrameError);\n    }\n  }\n  this.sendOrEnqueue(method, fields, reply);\n};\n\n// Shutdown protocol. There's three scenarios:\n//\n// 1. The application decides to shut the channel\n// 2. The server decides to shut the channel, possibly because of\n// something the application did\n// 3. The connection is closing, so there won't be any more frames\n// going back and forth.\n//\n// 1 and 2 involve an exchange of method frames (Close and CloseOk),\n// while 3 doesn't; the connection simply says \"shutdown\" to the\n// channel, which then acts as if it's closing, without going through\n// the exchange.\n\nfunction invalidOp(msg, stack) {\n  return function () {\n    throw new IllegalOperationError(msg, stack);\n  };\n}\nfunction invalidateSend(ch, msg, stack) {\n  ch.sendImmediately = ch.sendOrEnqueue = ch.sendMessage = invalidOp(msg, stack);\n}\n\n// Move to entirely closed state.\nC.toClosed = function (capturedStack) {\n  this._rejectPending();\n  invalidateSend(this, 'Channel closed', capturedStack);\n  this.accept = invalidOp('Channel closed', capturedStack);\n  this.connection.releaseChannel(this.ch);\n  this.emit('close');\n};\n\n// Stop being able to send and receive methods and content. Used when\n// we close the channel. Invokes the continuation once the server has\n// acknowledged the close, but before the channel is moved to the\n// closed state.\nC.toClosing = function (capturedStack, k) {\n  var send = this.sendImmediately.bind(this);\n  invalidateSend(this, 'Channel closing', capturedStack);\n  this.accept = function (f) {\n    if (f.id === defs.ChannelCloseOk) {\n      if (k) k();\n      var s = stackCapture('ChannelCloseOk frame received');\n      this.toClosed(s);\n    } else if (f.id === defs.ChannelClose) {\n      send(defs.ChannelCloseOk, {});\n    }\n    // else ignore frame\n  };\n};\nC._rejectPending = function () {\n  function rej(r) {\n    r(new Error(\"Channel ended, no reply will be forthcoming\"));\n  }\n  if (this.reply !== null) rej(this.reply);\n  this.reply = null;\n  var discard;\n  while (discard = this.pending.shift()) rej(discard.reply);\n  this.pending = null; // so pushes will break\n};\nC.closeBecause = function (reason, code, k) {\n  this.sendImmediately(defs.ChannelClose, {\n    replyText: reason,\n    replyCode: code,\n    methodId: 0,\n    classId: 0\n  });\n  var s = stackCapture('closeBecause called: ' + reason);\n  this.toClosing(s, k);\n};\n\n// If we close because there's been an error, we need to distinguish\n// between what we tell the server (`reason`) and what we report as\n// the cause in the client (`error`).\nC.closeWithError = function (id, reason, code, error) {\n  var self = this;\n  this.closeBecause(reason, code, function () {\n    error.code = code;\n    // content frames and consumer errors do not provide a method a class/method ID\n    if (id) {\n      error.classId = defs.info(id).classId;\n      error.methodId = defs.info(id).methodId;\n    }\n    self.emit('error', error);\n  });\n};\n\n// A trampolining state machine for message frames on a channel. A\n// message arrives in at least two frames: first, a method announcing\n// the message (either a BasicDeliver or BasicGetOk); then, a message\n// header with the message properties; then, zero or more content\n// frames.\n\n// Keep the try/catch localised, in an attempt to avoid disabling\n// optimisation\nC.acceptMessageFrame = function (f) {\n  try {\n    this.handleMessage = this.handleMessage(f);\n  } catch (msg) {\n    if (typeof msg === 'string') {\n      this.closeWithError(f.id, msg, defs.constants.UNEXPECTED_FRAME, new Error(msg));\n    } else if (msg instanceof Error) {\n      this.closeWithError(f.id, 'Error while processing message', defs.constants.INTERNAL_ERROR, msg);\n    } else {\n      this.closeWithError(f.id, 'Internal error while processing message', defs.constants.INTERNAL_ERROR, new Error(msg.toString()));\n    }\n  }\n};\n\n// Kick off a message delivery given a BasicDeliver or BasicReturn\n// frame (BasicGet uses the RPC mechanism)\nfunction acceptDeliveryOrReturn(f) {\n  var event;\n  if (f.id === defs.BasicDeliver) event = 'delivery';else if (f.id === defs.BasicReturn) event = 'return';else throw fmt(\"Expected BasicDeliver or BasicReturn; got %s\", inspect(f));\n  var self = this;\n  var fields = f.fields;\n  return acceptMessage(function (message) {\n    message.fields = fields;\n    self.emit(event, message);\n  });\n}\n\n// Move to the state of waiting for message frames (headers, then\n// one or more content frames)\nfunction acceptMessage(continuation) {\n  var totalSize = 0,\n    remaining = 0;\n  var buffers = null;\n  var message = {\n    fields: null,\n    properties: null,\n    content: null\n  };\n  return headers;\n\n  // expect a headers frame\n  function headers(f) {\n    if (f.id === defs.BasicProperties) {\n      message.properties = f.fields;\n      totalSize = remaining = f.size;\n\n      // for zero-length messages, content frames aren't required.\n      if (totalSize === 0) {\n        message.content = Buffer.alloc(0);\n        continuation(message);\n        return acceptDeliveryOrReturn;\n      } else {\n        return content;\n      }\n    } else {\n      throw \"Expected headers frame after delivery\";\n    }\n  }\n\n  // expect a content frame\n  // %%% TODO cancelled messages (sent as zero-length content frame)\n  function content(f) {\n    if (f.content) {\n      var size = f.content.length;\n      remaining -= size;\n      if (remaining === 0) {\n        if (buffers !== null) {\n          buffers.push(f.content);\n          message.content = Buffer.concat(buffers);\n        } else {\n          message.content = f.content;\n        }\n        continuation(message);\n        return acceptDeliveryOrReturn;\n      } else if (remaining < 0) {\n        throw fmt(\"Too much content sent! Expected %d bytes\", totalSize);\n      } else {\n        if (buffers !== null) buffers.push(f.content);else buffers = [f.content];\n        return content;\n      }\n    } else throw \"Expected content frame after headers\";\n  }\n}\nC.handleConfirm = function (handle, f) {\n  var tag = f.deliveryTag;\n  var multi = f.multiple;\n  if (multi) {\n    var confirmed = this.unconfirmed.splice(0, tag - this.lwm + 1);\n    this.lwm = tag + 1;\n    confirmed.forEach(handle);\n  } else {\n    var c;\n    if (tag === this.lwm) {\n      c = this.unconfirmed.shift();\n      this.lwm++;\n      // Advance the LWM and the window to the next non-gap, or\n      // possibly to the end\n      while (this.unconfirmed[0] === null) {\n        this.unconfirmed.shift();\n        this.lwm++;\n      }\n    } else {\n      c = this.unconfirmed[tag - this.lwm];\n      this.unconfirmed[tag - this.lwm] = null;\n    }\n    // Technically, in the single-deliveryTag case, I should report a\n    // protocol breach if it's already been confirmed.\n    handle(c);\n  }\n};\nC.pushConfirmCallback = function (cb) {\n  // `null` is used specifically for marking already confirmed slots,\n  // so I coerce `undefined` and `null` to false; functions are never\n  // falsey.\n  this.unconfirmed.push(cb || false);\n};\n\n// Interface for connection to use\n\nC.accept = function (f) {\n  switch (f.id) {\n    // Message frames\n    case undefined: // content frame!\n    case defs.BasicDeliver:\n    case defs.BasicReturn:\n    case defs.BasicProperties:\n      return this.acceptMessageFrame(f);\n\n    // confirmations, need to do confirm.select first\n    case defs.BasicAck:\n      return this.emit('ack', f.fields);\n    case defs.BasicNack:\n      return this.emit('nack', f.fields);\n    case defs.BasicCancel:\n      // The broker can send this if e.g., the queue is deleted.\n      return this.emit('cancel', f.fields);\n    case defs.ChannelClose:\n      // Any remote closure is an error to us. Reject the pending reply\n      // with the close frame, so it can see whether it was that\n      // operation that caused it to close.\n      if (this.reply) {\n        var reply = this.reply;\n        this.reply = null;\n        reply(f);\n      }\n      var emsg = \"Channel closed by server: \" + closeMsg(f);\n      this.sendImmediately(defs.ChannelCloseOk, {});\n      var error = new Error(emsg);\n      error.code = f.fields.replyCode;\n      error.classId = f.fields.classId;\n      error.methodId = f.fields.methodId;\n      this.emit('error', error);\n      var s = stackCapture(emsg);\n      this.toClosed(s);\n      return;\n    case defs.BasicFlow:\n      // RabbitMQ doesn't send this, it just blocks the TCP socket\n      return this.closeWithError(f.id, \"Flow not implemented\", defs.constants.NOT_IMPLEMENTED, new Error('Flow not implemented'));\n    default:\n      // assume all other things are replies\n      // Resolving the reply may lead to another RPC; to make sure we\n      // don't hold that up, clear this.reply\n      var reply = this.reply;\n      this.reply = null;\n      // however, maybe there's an RPC waiting to go? If so, that'll\n      // fill this.reply again, restoring the invariant. This does rely\n      // on any response being recv'ed after resolving the promise,\n      // below; hence, I use synchronous defer.\n      if (this.pending.length > 0) {\n        var send = this.pending.shift();\n        this.reply = send.reply;\n        this.sendImmediately(send.method, send.fields);\n      }\n      return reply(null, f);\n  }\n};\nC.onBufferDrain = function () {\n  this.emit('drain');\n};\n\n// This adds just a bit more stuff useful for the APIs, but not\n// low-level machinery.\nfunction BaseChannel(connection) {\n  Channel.call(this, connection);\n  this.consumers = new Map();\n}\ninherits(BaseChannel, Channel);\nmodule.exports.BaseChannel = BaseChannel;\n\n// Not sure I like the ff, it's going to be changing hidden classes\n// all over the place. On the other hand, whaddya do.\nBaseChannel.prototype.registerConsumer = function (tag, callback) {\n  this.consumers.set(tag, callback);\n};\nBaseChannel.prototype.unregisterConsumer = function (tag) {\n  this.consumers.delete(tag);\n};\nBaseChannel.prototype.dispatchMessage = function (fields, message) {\n  var consumerTag = fields.consumerTag;\n  var consumer = this.consumers.get(consumerTag);\n  if (consumer) {\n    return consumer(message);\n  } else {\n    // %%% Surely a race here\n    throw new Error(\"Unknown consumer: \" + consumerTag);\n  }\n};\nBaseChannel.prototype.handleDelivery = function (message) {\n  return this.dispatchMessage(message.fields, message);\n};\nBaseChannel.prototype.handleCancel = function (fields) {\n  var result = this.dispatchMessage(fields, null);\n  this.unregisterConsumer(fields.consumerTag);\n  return result;\n};","map":{"version":3,"names":["defs","require","closeMsg","closeMessage","inspect","methodName","assert","inherits","EventEmitter","fmt","format","IllegalOperationError","stackCapture","Channel","connection","call","reply","pending","lwm","unconfirmed","on","handleConfirm","bind","cb","Error","shift","handleMessage","acceptDeliveryOrReturn","module","exports","acceptMessage","C","prototype","allocate","ch","freshChannel","sendImmediately","method","fields","sendMethod","sendOrEnqueue","length","push","sendMessage","properties","content","BasicPublish","BasicProperties","_rpc","expect","self","err","f","id","expectedName","e","closeWithError","constants","UNEXPECTED_FRAME","closeReason","classId","methodId","closeFrameError","code","replyCode","invalidOp","msg","stack","invalidateSend","toClosed","capturedStack","_rejectPending","accept","releaseChannel","emit","toClosing","k","send","ChannelCloseOk","s","ChannelClose","rej","r","discard","closeBecause","reason","replyText","error","info","acceptMessageFrame","INTERNAL_ERROR","toString","event","BasicDeliver","BasicReturn","message","continuation","totalSize","remaining","buffers","headers","size","Buffer","alloc","concat","handle","tag","deliveryTag","multi","multiple","confirmed","splice","forEach","c","pushConfirmCallback","undefined","BasicAck","BasicNack","BasicCancel","emsg","BasicFlow","NOT_IMPLEMENTED","onBufferDrain","BaseChannel","consumers","Map","registerConsumer","callback","set","unregisterConsumer","delete","dispatchMessage","consumerTag","consumer","get","handleDelivery","handleCancel","result"],"sources":["/home/jp228/Desktop/frontend/node_modules/amqplib/lib/channel.js"],"sourcesContent":["//\n//\n//\n\n// Channel machinery.\n\n'use strict';\n\nvar defs = require('./defs');\nvar closeMsg = require('./format').closeMessage;\nvar inspect = require('./format').inspect;\nvar methodName = require('./format').methodName;\nvar assert = require('assert');\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\nvar fmt = require('util').format;\nvar IllegalOperationError = require('./error').IllegalOperationError;\nvar stackCapture = require('./error').stackCapture;\nfunction Channel(connection) {\n  EventEmitter.call( this );\n  this.connection = connection;\n  // for the presently outstanding RPC\n  this.reply = null;\n  // for the RPCs awaiting action\n  this.pending = [];\n  // for unconfirmed messages\n  this.lwm = 1; // the least, unconfirmed deliveryTag\n  this.unconfirmed = []; // rolling window of delivery callbacks\n  this.on('ack', this.handleConfirm.bind(this, function(cb) {\n    if (cb) cb(null);\n  }));\n  this.on('nack', this.handleConfirm.bind(this, function(cb) {\n    if (cb) cb(new Error('message nacked'));\n  }));\n  this.on('close', function () {\n    var cb;\n    while (cb = this.unconfirmed.shift()) {\n      if (cb) cb(new Error('channel closed'));\n    }\n  })\n  // message frame state machine\n  this.handleMessage = acceptDeliveryOrReturn;\n}\ninherits(Channel, EventEmitter);\n\nmodule.exports.Channel = Channel;\nmodule.exports.acceptMessage = acceptMessage;\n\nvar C = Channel.prototype;\n\nC.allocate = function() {\n  this.ch = this.connection.freshChannel(this);\n  return this;\n}\n\n// Incoming frames are either notifications of e.g., message delivery,\n// or replies to something we've sent. In general I deal with the\n// former by emitting an event, and with the latter by keeping a track\n// of what's expecting a reply.\n//\n// The AMQP specification implies that RPCs can't be pipelined; that\n// is, you can have only one outstanding RPC on a channel at a\n// time. Certainly that's what RabbitMQ and its clients assume. For\n// this reason, I buffer RPCs if the channel is already waiting for a\n// reply.\n\n// Just send the damn frame.\nC.sendImmediately = function(method, fields) {\n  return this.connection.sendMethod(this.ch, method, fields);\n};\n\n// Invariant: !this.reply -> pending.length == 0. That is, whenever we\n// clear a reply, we must send another RPC (and thereby fill\n// this.reply) if there is one waiting. The invariant relevant here\n// and in `accept`.\nC.sendOrEnqueue = function(method, fields, reply) {\n  if (!this.reply) { // if no reply waiting, we can go\n    assert(this.pending.length === 0);\n    this.reply = reply;\n    this.sendImmediately(method, fields);\n  }\n  else {\n    this.pending.push({method: method,\n                       fields: fields,\n                       reply: reply});\n  }\n};\n\nC.sendMessage = function(fields, properties, content) {\n  return this.connection.sendMessage(\n    this.ch,\n    defs.BasicPublish, fields,\n    defs.BasicProperties, properties,\n    content);\n};\n\n// Internal, synchronously resolved RPC; the return value is resolved\n// with the whole frame.\nC._rpc = function(method, fields, expect, cb) {\n  var self = this;\n\n  function reply(err, f) {\n    if (err === null) {\n      if (f.id === expect) {\n        return cb(null, f);\n      }\n      else {\n        // We have detected a problem, so it's up to us to close the\n        // channel\n        var expectedName = methodName(expect);\n\n        var e = new Error(fmt(\"Expected %s; got %s\",\n                              expectedName, inspect(f, false)));\n        self.closeWithError(f.id, fmt('Expected %s; got %s',\n                                expectedName, methodName(f.id)),\n                            defs.constants.UNEXPECTED_FRAME, e);\n        return cb(e);\n      }\n    }\n    // An error will be given if, for example, this is waiting to be\n    // sent and the connection closes\n    else if (err instanceof Error) return cb(err);\n    // A close frame will be given if this is the RPC awaiting reply\n    // and the channel is closed by the server\n    else {\n      // otherwise, it's a close frame\n      var closeReason =\n        (err.fields.classId << 16) + err.fields.methodId;\n      var e = (method === closeReason)\n        ? fmt(\"Operation failed: %s; %s\",\n              methodName(method), closeMsg(err))\n        : fmt(\"Channel closed by server: %s\", closeMsg(err));\n      var closeFrameError = new Error(e);\n      closeFrameError.code = err.fields.replyCode;\n      closeFrameError.classId = err.fields.classId;\n      closeFrameError.methodId = err.fields.methodId;\n      return cb(closeFrameError);\n    }\n  }\n\n  this.sendOrEnqueue(method, fields, reply);\n};\n\n// Shutdown protocol. There's three scenarios:\n//\n// 1. The application decides to shut the channel\n// 2. The server decides to shut the channel, possibly because of\n// something the application did\n// 3. The connection is closing, so there won't be any more frames\n// going back and forth.\n//\n// 1 and 2 involve an exchange of method frames (Close and CloseOk),\n// while 3 doesn't; the connection simply says \"shutdown\" to the\n// channel, which then acts as if it's closing, without going through\n// the exchange.\n\nfunction invalidOp(msg, stack) {\n  return function() {\n    throw new IllegalOperationError(msg, stack);\n  };\n}\n\nfunction invalidateSend(ch, msg, stack) {\n  ch.sendImmediately = ch.sendOrEnqueue = ch.sendMessage =\n    invalidOp(msg, stack);\n}\n\n// Move to entirely closed state.\nC.toClosed = function(capturedStack) {\n  this._rejectPending();\n  invalidateSend(this, 'Channel closed', capturedStack);\n  this.accept = invalidOp('Channel closed', capturedStack);\n  this.connection.releaseChannel(this.ch);\n  this.emit('close');\n};\n\n// Stop being able to send and receive methods and content. Used when\n// we close the channel. Invokes the continuation once the server has\n// acknowledged the close, but before the channel is moved to the\n// closed state.\nC.toClosing = function(capturedStack, k) {\n  var send = this.sendImmediately.bind(this);\n  invalidateSend(this, 'Channel closing', capturedStack);\n\n  this.accept = function(f) {\n    if (f.id === defs.ChannelCloseOk) {\n      if (k) k();\n      var s = stackCapture('ChannelCloseOk frame received');\n      this.toClosed(s);\n    }\n    else if (f.id === defs.ChannelClose) {\n      send(defs.ChannelCloseOk, {});\n    }\n    // else ignore frame\n  };\n};\n\nC._rejectPending = function() {\n  function rej(r) {\n    r(new Error(\"Channel ended, no reply will be forthcoming\"));\n  }\n  if (this.reply !== null) rej(this.reply);\n  this.reply = null;\n\n  var discard;\n  while (discard = this.pending.shift()) rej(discard.reply);\n  this.pending = null; // so pushes will break\n};\n\nC.closeBecause = function(reason, code, k) {\n  this.sendImmediately(defs.ChannelClose, {\n    replyText: reason,\n    replyCode: code,\n    methodId:0, classId: 0\n  });\n  var s = stackCapture('closeBecause called: ' + reason);\n  this.toClosing(s, k);\n};\n\n// If we close because there's been an error, we need to distinguish\n// between what we tell the server (`reason`) and what we report as\n// the cause in the client (`error`).\nC.closeWithError = function(id, reason, code, error) {\n  var self = this;\n  this.closeBecause(reason, code, function() {\n    error.code = code;\n    // content frames and consumer errors do not provide a method a class/method ID\n    if (id) {\n      error.classId = defs.info(id).classId;\n      error.methodId = defs.info(id).methodId;\n    }\n    self.emit('error', error);\n  });\n};\n\n// A trampolining state machine for message frames on a channel. A\n// message arrives in at least two frames: first, a method announcing\n// the message (either a BasicDeliver or BasicGetOk); then, a message\n// header with the message properties; then, zero or more content\n// frames.\n\n// Keep the try/catch localised, in an attempt to avoid disabling\n// optimisation\nC.acceptMessageFrame = function(f) {\n  try {\n    this.handleMessage = this.handleMessage(f);\n  }\n  catch (msg) {\n    if (typeof msg === 'string') {\n      this.closeWithError(f.id, msg, defs.constants.UNEXPECTED_FRAME,\n                          new Error(msg));\n    }\n    else if (msg instanceof Error) {\n      this.closeWithError(f.id, 'Error while processing message',\n                          defs.constants.INTERNAL_ERROR, msg);\n    }\n    else {\n      this.closeWithError(f.id, 'Internal error while processing message',\n                          defs.constants.INTERNAL_ERROR,\n                          new Error(msg.toString()));\n    }\n  }\n};\n\n// Kick off a message delivery given a BasicDeliver or BasicReturn\n// frame (BasicGet uses the RPC mechanism)\nfunction acceptDeliveryOrReturn(f) {\n  var event;\n  if (f.id === defs.BasicDeliver) event = 'delivery';\n  else if (f.id === defs.BasicReturn) event = 'return';\n  else throw fmt(\"Expected BasicDeliver or BasicReturn; got %s\",\n                 inspect(f));\n\n  var self = this;\n  var fields = f.fields;\n  return acceptMessage(function(message) {\n    message.fields = fields;\n    self.emit(event, message);\n  });\n}\n\n// Move to the state of waiting for message frames (headers, then\n// one or more content frames)\nfunction acceptMessage(continuation) {\n  var totalSize = 0, remaining = 0;\n  var buffers = null;\n\n  var message = {\n    fields: null,\n    properties: null,\n    content: null\n  };\n\n  return headers;\n\n  // expect a headers frame\n  function headers(f) {\n    if (f.id === defs.BasicProperties) {\n      message.properties = f.fields;\n      totalSize = remaining = f.size;\n\n      // for zero-length messages, content frames aren't required.\n      if (totalSize === 0) {\n        message.content = Buffer.alloc(0);\n        continuation(message);\n        return acceptDeliveryOrReturn;\n      }\n      else {\n        return content;\n      }\n    }\n    else {\n      throw \"Expected headers frame after delivery\";\n    }\n  }\n\n  // expect a content frame\n  // %%% TODO cancelled messages (sent as zero-length content frame)\n  function content(f) {\n    if (f.content) {\n      var size = f.content.length;\n      remaining -= size;\n      if (remaining === 0) {\n        if (buffers !== null) {\n          buffers.push(f.content);\n          message.content = Buffer.concat(buffers);\n        }\n        else {\n          message.content = f.content;\n        }\n        continuation(message);\n        return acceptDeliveryOrReturn;\n      }\n      else if (remaining < 0) {\n        throw fmt(\"Too much content sent! Expected %d bytes\",\n                  totalSize);\n      }\n      else {\n        if (buffers !== null)\n          buffers.push(f.content);\n        else\n          buffers = [f.content];\n        return content;\n      }\n    }\n    else throw \"Expected content frame after headers\"\n  }\n}\n\nC.handleConfirm = function(handle, f) {\n  var tag = f.deliveryTag;\n  var multi = f.multiple;\n\n  if (multi) {\n    var confirmed = this.unconfirmed.splice(0, tag - this.lwm + 1);\n    this.lwm = tag + 1;\n    confirmed.forEach(handle);\n  }\n  else {\n    var c;\n    if (tag === this.lwm) {\n      c = this.unconfirmed.shift();\n      this.lwm++;\n      // Advance the LWM and the window to the next non-gap, or\n      // possibly to the end\n      while (this.unconfirmed[0] === null) {\n        this.unconfirmed.shift();\n        this.lwm++;\n      }\n    }\n    else {\n      c = this.unconfirmed[tag - this.lwm];\n      this.unconfirmed[tag - this.lwm] = null;\n    }\n    // Technically, in the single-deliveryTag case, I should report a\n    // protocol breach if it's already been confirmed.\n    handle(c);\n  }\n};\n\nC.pushConfirmCallback = function(cb) {\n  // `null` is used specifically for marking already confirmed slots,\n  // so I coerce `undefined` and `null` to false; functions are never\n  // falsey.\n  this.unconfirmed.push(cb || false);\n};\n\n// Interface for connection to use\n\nC.accept = function(f) {\n\n  switch (f.id) {\n\n    // Message frames\n  case undefined: // content frame!\n  case defs.BasicDeliver:\n  case defs.BasicReturn:\n  case defs.BasicProperties:\n    return this.acceptMessageFrame(f);\n\n    // confirmations, need to do confirm.select first\n  case defs.BasicAck:\n    return this.emit('ack', f.fields);\n  case defs.BasicNack:\n    return this.emit('nack', f.fields);\n  case defs.BasicCancel:\n    // The broker can send this if e.g., the queue is deleted.\n    return this.emit('cancel', f.fields);\n\n  case defs.ChannelClose:\n    // Any remote closure is an error to us. Reject the pending reply\n    // with the close frame, so it can see whether it was that\n    // operation that caused it to close.\n    if (this.reply) {\n      var reply = this.reply; this.reply = null;\n      reply(f);\n    }\n    var emsg = \"Channel closed by server: \" + closeMsg(f);\n    this.sendImmediately(defs.ChannelCloseOk, {});\n\n    var error = new Error(emsg);\n    error.code = f.fields.replyCode;\n    error.classId = f.fields.classId;\n    error.methodId = f.fields.methodId;\n    this.emit('error', error);\n\n    var s = stackCapture(emsg);\n    this.toClosed(s);\n    return;\n\n  case defs.BasicFlow:\n    // RabbitMQ doesn't send this, it just blocks the TCP socket\n    return this.closeWithError(f.id, \"Flow not implemented\",\n                               defs.constants.NOT_IMPLEMENTED,\n                               new Error('Flow not implemented'));\n\n  default: // assume all other things are replies\n    // Resolving the reply may lead to another RPC; to make sure we\n    // don't hold that up, clear this.reply\n    var reply = this.reply; this.reply = null;\n    // however, maybe there's an RPC waiting to go? If so, that'll\n    // fill this.reply again, restoring the invariant. This does rely\n    // on any response being recv'ed after resolving the promise,\n    // below; hence, I use synchronous defer.\n    if (this.pending.length > 0) {\n      var send = this.pending.shift();\n      this.reply = send.reply;\n      this.sendImmediately(send.method, send.fields);\n    }\n    return reply(null, f);\n  }\n};\n\nC.onBufferDrain = function() {\n  this.emit('drain');\n};\n\n\n// This adds just a bit more stuff useful for the APIs, but not\n// low-level machinery.\nfunction BaseChannel(connection) {\n  Channel.call(this, connection);\n  this.consumers = new Map();\n}\ninherits(BaseChannel, Channel);\n\nmodule.exports.BaseChannel = BaseChannel;\n\n// Not sure I like the ff, it's going to be changing hidden classes\n// all over the place. On the other hand, whaddya do.\nBaseChannel.prototype.registerConsumer = function(tag, callback) {\n  this.consumers.set(tag, callback);\n};\n\nBaseChannel.prototype.unregisterConsumer = function(tag) {\n  this.consumers.delete(tag);\n};\n\nBaseChannel.prototype.dispatchMessage = function(fields, message) {\n  var consumerTag = fields.consumerTag;\n  var consumer = this.consumers.get(consumerTag);\n  if (consumer) {\n    return consumer(message);\n  }\n  else {\n    // %%% Surely a race here\n    throw new Error(\"Unknown consumer: \" + consumerTag);\n  }\n};\n\nBaseChannel.prototype.handleDelivery = function(message) {\n  return this.dispatchMessage(message.fields, message);\n};\n\nBaseChannel.prototype.handleCancel = function(fields) {\n  var result = this.dispatchMessage(fields, null);\n  this.unregisterConsumer(fields.consumerTag);\n  return result;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}