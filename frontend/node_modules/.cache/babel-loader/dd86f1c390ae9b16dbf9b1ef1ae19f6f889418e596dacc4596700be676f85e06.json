{"ast":null,"code":"//\n//\n//\n\n'use strict';\n\nvar defs = require('./defs');\nvar constants = defs.constants;\nvar frame = require('./frame');\nvar HEARTBEAT = frame.HEARTBEAT;\nvar Mux = require('./mux').Mux;\nvar Duplex = require('stream').Duplex || require('readable-stream/duplex');\nvar EventEmitter = require('events').EventEmitter;\nvar Heart = require('./heartbeat').Heart;\nvar methodName = require('./format').methodName;\nvar closeMsg = require('./format').closeMessage;\nvar inspect = require('./format').inspect;\nvar BitSet = require('./bitset').BitSet;\nvar inherits = require('util').inherits;\nvar fmt = require('util').format;\nvar PassThrough = require('stream').PassThrough || require('readable-stream/passthrough');\nvar IllegalOperationError = require('./error').IllegalOperationError;\nvar stackCapture = require('./error').stackCapture;\n\n// High-water mark for channel write buffers, in 'objects' (which are\n// encoded frames as buffers).\nvar DEFAULT_WRITE_HWM = 1024;\n// If all the frames of a message (method, properties, content) total\n// to less than this, copy them into a single buffer and write it all\n// at once. Note that this is less than the minimum frame size: if it\n// was greater, we might have to fragment the content.\nvar SINGLE_CHUNK_THRESHOLD = 2048;\nfunction Connection(underlying) {\n  EventEmitter.call(this);\n  var stream = this.stream = wrapStream(underlying);\n  this.muxer = new Mux(stream);\n\n  // frames\n  this.rest = Buffer.alloc(0);\n  this.frameMax = constants.FRAME_MIN_SIZE;\n  this.sentSinceLastCheck = false;\n  this.recvSinceLastCheck = false;\n  this.expectSocketClose = false;\n  this.freeChannels = new BitSet();\n  this.channels = [{\n    channel: {\n      accept: channel0(this)\n    },\n    buffer: underlying\n  }];\n}\ninherits(Connection, EventEmitter);\nvar C = Connection.prototype;\n\n// Usual frame accept mode\nfunction mainAccept(frame) {\n  var rec = this.channels[frame.channel];\n  if (rec) {\n    return rec.channel.accept(frame);\n  }\n  // NB CHANNEL_ERROR may not be right, but I don't know what is ..\n  else this.closeWithError(fmt('Frame on unknown channel %d', frame.channel), constants.CHANNEL_ERROR, new Error(fmt(\"Frame on unknown channel: %s\", inspect(frame, false))));\n}\n\n// Handle anything that comes through on channel 0, that's the\n// connection control channel. This is only used once mainAccept is\n// installed as the frame handler, after the opening handshake.\nfunction channel0(connection) {\n  return function (f) {\n    // Once we get a 'close', we know 1. we'll get no more frames, and\n    // 2. anything we send except close, or close-ok, will be\n    // ignored. If we already sent 'close', this won't be invoked since\n    // we're already in closing mode; if we didn't well we're not going\n    // to send it now are we.\n    if (f === HEARTBEAT) ; // ignore; it's already counted as activity\n    // on the socket, which is its purpose\n    else if (f.id === defs.ConnectionClose) {\n      // Oh. OK. I guess we're done here then.\n      connection.sendMethod(0, defs.ConnectionCloseOk, {});\n      var emsg = fmt('Connection closed: %s', closeMsg(f));\n      var s = stackCapture(emsg);\n      var e = new Error(emsg);\n      e.code = f.fields.replyCode;\n      if (isFatalError(e)) {\n        connection.emit('error', e);\n      }\n      connection.toClosed(s, e);\n    } else if (f.id === defs.ConnectionBlocked) {\n      connection.emit('blocked', f.fields.reason);\n    } else if (f.id === defs.ConnectionUnblocked) {\n      connection.emit('unblocked');\n    } else {\n      connection.closeWithError(fmt(\"Unexpected frame on channel 0\"), constants.UNEXPECTED_FRAME, new Error(fmt(\"Unexpected frame on channel 0: %s\", inspect(f, false))));\n    }\n  };\n}\n\n// This changed between versions, as did the codec, methods, etc. AMQP\n// 0-9-1 is fairly similar to 0.8, but better, and nothing implements\n// 0.8 that doesn't implement 0-9-1. In other words, it doesn't make\n// much sense to generalise here.\nC.sendProtocolHeader = function () {\n  this.sendBytes(frame.PROTOCOL_HEADER);\n};\n\n/*\n  The frighteningly complicated opening protocol (spec section 2.2.4):\n\n     Client -> Server\n\n       protocol header ->\n         <- start\n       start-ok ->\n     .. next two zero or more times ..\n         <- secure\n       secure-ok ->\n         <- tune\n       tune-ok ->\n       open ->\n         <- open-ok\n\nIf I'm only supporting SASL's PLAIN mechanism (which I am for the time\nbeing), it gets a bit easier since the server won't in general send\nback a `secure`, it'll just send `tune` after the `start-ok`.\n(SASL PLAIN: http://tools.ietf.org/html/rfc4616)\n\n*/\n\nC.open = function (allFields, openCallback0) {\n  var self = this;\n  var openCallback = openCallback0 || function () {};\n\n  // This is where we'll put our negotiated values\n  var tunedOptions = Object.create(allFields);\n  function wait(k) {\n    self.step(function (err, frame) {\n      if (err !== null) bail(err);else if (frame.channel !== 0) {\n        bail(new Error(fmt(\"Frame on channel != 0 during handshake: %s\", inspect(frame, false))));\n      } else k(frame);\n    });\n  }\n  function expect(Method, k) {\n    wait(function (frame) {\n      if (frame.id === Method) k(frame);else {\n        bail(new Error(fmt(\"Expected %s; got %s\", methodName(Method), inspect(frame, false))));\n      }\n    });\n  }\n  function bail(err) {\n    openCallback(err);\n  }\n  function send(Method) {\n    // This can throw an exception if there's some problem with the\n    // options; e.g., something is a string instead of a number.\n    self.sendMethod(0, Method, tunedOptions);\n  }\n  function negotiate(server, desired) {\n    // We get sent values for channelMax, frameMax and heartbeat,\n    // which we may accept or lower (subject to a minimum for\n    // frameMax, but we'll leave that to the server to enforce). In\n    // all cases, `0` really means \"no limit\", or rather the highest\n    // value in the encoding, e.g., unsigned short for channelMax.\n    if (server === 0 || desired === 0) {\n      // i.e., whichever places a limit, if either\n      return Math.max(server, desired);\n    } else {\n      return Math.min(server, desired);\n    }\n  }\n  function onStart(start) {\n    var mechanisms = start.fields.mechanisms.toString().split(' ');\n    if (mechanisms.indexOf(allFields.mechanism) < 0) {\n      bail(new Error(fmt('SASL mechanism %s is not provided by the server', allFields.mechanism)));\n      return;\n    }\n    self.serverProperties = start.fields.serverProperties;\n    try {\n      send(defs.ConnectionStartOk);\n    } catch (err) {\n      bail(err);\n      return;\n    }\n    wait(afterStartOk);\n  }\n  function afterStartOk(reply) {\n    switch (reply.id) {\n      case defs.ConnectionSecure:\n        bail(new Error(\"Wasn't expecting to have to go through secure\"));\n        break;\n      case defs.ConnectionClose:\n        bail(new Error(fmt(\"Handshake terminated by server: %s\", closeMsg(reply))));\n        break;\n      case defs.ConnectionTune:\n        var fields = reply.fields;\n        tunedOptions.frameMax = negotiate(fields.frameMax, allFields.frameMax);\n        tunedOptions.channelMax = negotiate(fields.channelMax, allFields.channelMax);\n        tunedOptions.heartbeat = negotiate(fields.heartbeat, allFields.heartbeat);\n        try {\n          send(defs.ConnectionTuneOk);\n          send(defs.ConnectionOpen);\n        } catch (err) {\n          bail(err);\n          return;\n        }\n        expect(defs.ConnectionOpenOk, onOpenOk);\n        break;\n      default:\n        bail(new Error(fmt(\"Expected connection.secure, connection.close, \" + \"or connection.tune during handshake; got %s\", inspect(reply, false))));\n        break;\n    }\n  }\n  function onOpenOk(openOk) {\n    // Impose the maximum of the encoded value, if the negotiated\n    // value is zero, meaning \"no, no limits\"\n    self.channelMax = tunedOptions.channelMax || 0xffff;\n    self.frameMax = tunedOptions.frameMax || 0xffffffff;\n    // 0 means \"no heartbeat\", rather than \"maximum period of\n    // heartbeating\"\n    self.heartbeat = tunedOptions.heartbeat;\n    self.heartbeater = self.startHeartbeater();\n    self.accept = mainAccept;\n    succeed(openOk);\n  }\n\n  // If the server closes the connection, it's probably because of\n  // something we did\n  function endWhileOpening(err) {\n    bail(err || new Error('Socket closed abruptly ' + 'during opening handshake'));\n  }\n  this.stream.on('end', endWhileOpening);\n  this.stream.on('error', endWhileOpening);\n  function succeed(ok) {\n    self.stream.removeListener('end', endWhileOpening);\n    self.stream.removeListener('error', endWhileOpening);\n    self.stream.on('error', self.onSocketError.bind(self));\n    self.stream.on('end', self.onSocketError.bind(self, new Error('Unexpected close')));\n    self.on('frameError', self.onSocketError.bind(self));\n    self.acceptLoop();\n    openCallback(null, ok);\n  }\n\n  // Now kick off the handshake by prompting the server\n  this.sendProtocolHeader();\n  expect(defs.ConnectionStart, onStart);\n};\n\n// Closing things: AMQP has a closing handshake that applies to\n// closing both connects and channels. As the initiating party, I send\n// Close, then ignore all frames until I see either CloseOK --\n// which signifies that the other party has seen the Close and shut\n// the connection or channel down, so it's fine to free resources; or\n// Close, which means the other party also wanted to close the\n// whatever, and I should send CloseOk so it can free resources,\n// then go back to waiting for the CloseOk. If I receive a Close\n// out of the blue, I should throw away any unsent frames (they will\n// be ignored anyway) and send CloseOk, then clean up resources. In\n// general, Close out of the blue signals an error (or a forced\n// closure, which may as well be an error).\n//\n//  RUNNING [1] --- send Close ---> Closing [2] ---> recv Close --+\n//     |                               |                         [3]\n//     |                               +------ send CloseOk ------+\n//  recv Close                   recv CloseOk\n//     |                               |\n//     V                               V\n//  Ended [4] ---- send CloseOk ---> Closed [5]\n//\n// [1] All frames accepted; getting a Close frame from the server\n// moves to Ended; client may initiate a close by sending Close\n// itself.\n// [2] Client has initiated a close; only CloseOk or (simulataneously\n// sent) Close is accepted.\n// [3] Simultaneous close\n// [4] Server won't send any more frames; accept no more frames, send\n// CloseOk.\n// [5] Fully closed, client will send no more, server will send no\n// more. Signal 'close' or 'error'.\n//\n// There are two signalling mechanisms used in the API. The first is\n// that calling `close` will return a promise, that will either\n// resolve once the connection or channel is cleanly shut down, or\n// will reject if the shutdown times out.\n//\n// The second is the 'close' and 'error' events. These are\n// emitted as above. The events will fire *before* promises are\n// resolved.\n\n// Close the connection without even giving a reason. Typical.\nC.close = function (closeCallback) {\n  var k = closeCallback && function () {\n    closeCallback(null);\n  };\n  this.closeBecause(\"Cheers, thanks\", constants.REPLY_SUCCESS, k);\n};\n\n// Close with a reason and a 'code'. I'm pretty sure RabbitMQ totally\n// ignores these; maybe it logs them. The continuation will be invoked\n// when the CloseOk has been received, and before the 'close' event.\nC.closeBecause = function (reason, code, k) {\n  this.sendMethod(0, defs.ConnectionClose, {\n    replyText: reason,\n    replyCode: code,\n    methodId: 0,\n    classId: 0\n  });\n  var s = stackCapture('closeBecause called: ' + reason);\n  this.toClosing(s, k);\n};\nC.closeWithError = function (reason, code, error) {\n  this.emit('error', error);\n  this.closeBecause(reason, code);\n};\nC.onSocketError = function (err) {\n  if (!this.expectSocketClose) {\n    // forestall any more calls to onSocketError, since we're signed\n    // up for `'error'` *and* `'end'`\n    this.expectSocketClose = true;\n    this.emit('error', err);\n    var s = stackCapture('Socket error');\n    this.toClosed(s, err);\n  }\n};\nfunction invalidOp(msg, stack) {\n  return function () {\n    throw new IllegalOperationError(msg, stack);\n  };\n}\nfunction invalidateSend(conn, msg, stack) {\n  conn.sendMethod = conn.sendContent = conn.sendMessage = invalidOp(msg, stack);\n}\n\n// A close has been initiated. Repeat: a close has been initiated.\n// This means we should not send more frames, anyway they will be\n// ignored. We also have to shut down all the channels.\nC.toClosing = function (capturedStack, k) {\n  var send = this.sendMethod.bind(this);\n  this.accept = function (f) {\n    if (f.id === defs.ConnectionCloseOk) {\n      if (k) k();\n      var s = stackCapture('ConnectionCloseOk received');\n      this.toClosed(s, undefined);\n    } else if (f.id === defs.ConnectionClose) {\n      send(0, defs.ConnectionCloseOk, {});\n    }\n    // else ignore frame\n  };\n  invalidateSend(this, 'Connection closing', capturedStack);\n};\nC._closeChannels = function (capturedStack) {\n  for (var i = 1; i < this.channels.length; i++) {\n    var ch = this.channels[i];\n    if (ch !== null) {\n      ch.channel.toClosed(capturedStack); // %%% or with an error? not clear\n    }\n  }\n};\n\n// A close has been confirmed. Cease all communication.\nC.toClosed = function (capturedStack, maybeErr) {\n  this._closeChannels(capturedStack);\n  var info = fmt('Connection closed (%s)', maybeErr ? maybeErr.toString() : 'by client');\n  // Tidy up, invalidate enverything, dynamite the bridges.\n  invalidateSend(this, info, capturedStack);\n  this.accept = invalidOp(info, capturedStack);\n  this.close = function (cb) {\n    cb && cb(new IllegalOperationError(info, capturedStack));\n  };\n  if (this.heartbeater) this.heartbeater.clear();\n  // This is certainly true now, if it wasn't before\n  this.expectSocketClose = true;\n  this.stream.end();\n  this.emit('close', maybeErr);\n};\n\n// ===\n\nC.startHeartbeater = function () {\n  if (this.heartbeat === 0) return null;else {\n    var self = this;\n    var hb = new Heart(this.heartbeat, this.checkSend.bind(this), this.checkRecv.bind(this));\n    hb.on('timeout', function () {\n      var hberr = new Error(\"Heartbeat timeout\");\n      self.emit('error', hberr);\n      var s = stackCapture('Heartbeat timeout');\n      self.toClosed(s, hberr);\n    });\n    hb.on('beat', function () {\n      self.sendHeartbeat();\n    });\n    return hb;\n  }\n};\n\n// I use an array to keep track of the channels, rather than an\n// object. The channel identifiers are numbers, and allocated by the\n// connection. If I try to allocate low numbers when they are\n// available (which I do, by looking from the start of the bitset),\n// this ought to keep the array small, and out of 'sparse array\n// storage'. I also set entries to null, rather than deleting them, in\n// the expectation that the next channel allocation will fill the slot\n// again rather than growing the array. See\n// http://www.html5rocks.com/en/tutorials/speed/v8/\nC.freshChannel = function (channel, options) {\n  var next = this.freeChannels.nextClearBit(1);\n  if (next < 0 || next > this.channelMax) throw new Error(\"No channels left to allocate\");\n  this.freeChannels.set(next);\n  var hwm = options && options.highWaterMark || DEFAULT_WRITE_HWM;\n  var writeBuffer = new PassThrough({\n    objectMode: true,\n    highWaterMark: hwm\n  });\n  this.channels[next] = {\n    channel: channel,\n    buffer: writeBuffer\n  };\n  writeBuffer.on('drain', function () {\n    channel.onBufferDrain();\n  });\n  this.muxer.pipeFrom(writeBuffer);\n  return next;\n};\nC.releaseChannel = function (channel) {\n  this.freeChannels.clear(channel);\n  var buffer = this.channels[channel].buffer;\n  buffer.end(); // will also cause it to be unpiped\n  this.channels[channel] = null;\n};\nC.acceptLoop = function () {\n  var self = this;\n  function go() {\n    try {\n      var f;\n      while (f = self.recvFrame()) self.accept(f);\n    } catch (e) {\n      self.emit('frameError', e);\n    }\n  }\n  self.stream.on('readable', go);\n  go();\n};\nC.step = function (cb) {\n  var self = this;\n  function recv() {\n    var f;\n    try {\n      f = self.recvFrame();\n    } catch (e) {\n      cb(e, null);\n      return;\n    }\n    if (f) cb(null, f);else self.stream.once('readable', recv);\n  }\n  recv();\n};\nC.checkSend = function () {\n  var check = this.sentSinceLastCheck;\n  this.sentSinceLastCheck = false;\n  return check;\n};\nC.checkRecv = function () {\n  var check = this.recvSinceLastCheck;\n  this.recvSinceLastCheck = false;\n  return check;\n};\nC.sendBytes = function (bytes) {\n  this.sentSinceLastCheck = true;\n  this.stream.write(bytes);\n};\nC.sendHeartbeat = function () {\n  return this.sendBytes(frame.HEARTBEAT_BUF);\n};\nvar encodeMethod = defs.encodeMethod;\nvar encodeProperties = defs.encodeProperties;\nC.sendMethod = function (channel, Method, fields) {\n  var frame = encodeMethod(Method, channel, fields);\n  this.sentSinceLastCheck = true;\n  var buffer = this.channels[channel].buffer;\n  return buffer.write(frame);\n};\nC.sendMessage = function (channel, Method, fields, Properties, props, content) {\n  if (!Buffer.isBuffer(content)) throw new TypeError('content is not a buffer');\n  var mframe = encodeMethod(Method, channel, fields);\n  var pframe = encodeProperties(Properties, channel, content.length, props);\n  var buffer = this.channels[channel].buffer;\n  this.sentSinceLastCheck = true;\n  var methodHeaderLen = mframe.length + pframe.length;\n  var bodyLen = content.length > 0 ? content.length + FRAME_OVERHEAD : 0;\n  var allLen = methodHeaderLen + bodyLen;\n  if (allLen < SINGLE_CHUNK_THRESHOLD) {\n    // Use `allocUnsafe` to avoid excessive allocations and CPU usage\n    // from zeroing. The returned Buffer is not zeroed and so must be\n    // completely filled to be used safely.\n    // See https://github.com/amqp-node/amqplib/pull/695\n    var all = Buffer.allocUnsafe(allLen);\n    var offset = mframe.copy(all, 0);\n    offset += pframe.copy(all, offset);\n    if (bodyLen > 0) makeBodyFrame(channel, content).copy(all, offset);\n    return buffer.write(all);\n  } else {\n    if (methodHeaderLen < SINGLE_CHUNK_THRESHOLD) {\n      // Use `allocUnsafe` to avoid excessive allocations and CPU usage\n      // from zeroing. The returned Buffer is not zeroed and so must be\n      // completely filled to be used safely.\n      // See https://github.com/amqp-node/amqplib/pull/695\n      var both = Buffer.allocUnsafe(methodHeaderLen);\n      var offset = mframe.copy(both, 0);\n      pframe.copy(both, offset);\n      buffer.write(both);\n    } else {\n      buffer.write(mframe);\n      buffer.write(pframe);\n    }\n    return this.sendContent(channel, content);\n  }\n};\nvar FRAME_OVERHEAD = defs.FRAME_OVERHEAD;\nvar makeBodyFrame = frame.makeBodyFrame;\nC.sendContent = function (channel, body) {\n  if (!Buffer.isBuffer(body)) {\n    throw new TypeError(fmt(\"Expected buffer; got %s\", body));\n  }\n  var writeResult = true;\n  var buffer = this.channels[channel].buffer;\n  var maxBody = this.frameMax - FRAME_OVERHEAD;\n  for (var offset = 0; offset < body.length; offset += maxBody) {\n    var end = offset + maxBody;\n    var slice = end > body.length ? body.slice(offset) : body.slice(offset, end);\n    var bodyFrame = makeBodyFrame(channel, slice);\n    writeResult = buffer.write(bodyFrame);\n  }\n  this.sentSinceLastCheck = true;\n  return writeResult;\n};\nvar parseFrame = frame.parseFrame;\nvar decodeFrame = frame.decodeFrame;\nC.recvFrame = function () {\n  // %%% identifying invariants might help here?\n  var frame = parseFrame(this.rest, this.frameMax);\n  if (!frame) {\n    var incoming = this.stream.read();\n    if (incoming === null) {\n      return false;\n    } else {\n      this.recvSinceLastCheck = true;\n      this.rest = Buffer.concat([this.rest, incoming]);\n      return this.recvFrame();\n    }\n  } else {\n    this.rest = frame.rest;\n    return decodeFrame(frame);\n  }\n};\nfunction wrapStream(s) {\n  if (s instanceof Duplex) return s;else {\n    var ws = new Duplex();\n    ws.wrap(s); //wraps the readable side of things\n    ws._write = function (chunk, encoding, callback) {\n      return s.write(chunk, encoding, callback);\n    };\n    return ws;\n  }\n}\nfunction isFatalError(error) {\n  switch (error && error.code) {\n    case defs.constants.CONNECTION_FORCED:\n    case defs.constants.REPLY_SUCCESS:\n      return false;\n    default:\n      return true;\n  }\n}\nmodule.exports.Connection = Connection;\nmodule.exports.isFatalError = isFatalError;","map":{"version":3,"names":["defs","require","constants","frame","HEARTBEAT","Mux","Duplex","EventEmitter","Heart","methodName","closeMsg","closeMessage","inspect","BitSet","inherits","fmt","format","PassThrough","IllegalOperationError","stackCapture","DEFAULT_WRITE_HWM","SINGLE_CHUNK_THRESHOLD","Connection","underlying","call","stream","wrapStream","muxer","rest","Buffer","alloc","frameMax","FRAME_MIN_SIZE","sentSinceLastCheck","recvSinceLastCheck","expectSocketClose","freeChannels","channels","channel","accept","channel0","buffer","C","prototype","mainAccept","rec","closeWithError","CHANNEL_ERROR","Error","connection","f","id","ConnectionClose","sendMethod","ConnectionCloseOk","emsg","s","e","code","fields","replyCode","isFatalError","emit","toClosed","ConnectionBlocked","reason","ConnectionUnblocked","UNEXPECTED_FRAME","sendProtocolHeader","sendBytes","PROTOCOL_HEADER","open","allFields","openCallback0","self","openCallback","tunedOptions","Object","create","wait","k","step","err","bail","expect","Method","send","negotiate","server","desired","Math","max","min","onStart","start","mechanisms","toString","split","indexOf","mechanism","serverProperties","ConnectionStartOk","afterStartOk","reply","ConnectionSecure","ConnectionTune","channelMax","heartbeat","ConnectionTuneOk","ConnectionOpen","ConnectionOpenOk","onOpenOk","openOk","heartbeater","startHeartbeater","succeed","endWhileOpening","on","ok","removeListener","onSocketError","bind","acceptLoop","ConnectionStart","close","closeCallback","closeBecause","REPLY_SUCCESS","replyText","methodId","classId","toClosing","error","invalidOp","msg","stack","invalidateSend","conn","sendContent","sendMessage","capturedStack","undefined","_closeChannels","i","length","ch","maybeErr","info","cb","clear","end","hb","checkSend","checkRecv","hberr","sendHeartbeat","freshChannel","options","next","nextClearBit","set","hwm","highWaterMark","writeBuffer","objectMode","onBufferDrain","pipeFrom","releaseChannel","go","recvFrame","recv","once","check","bytes","write","HEARTBEAT_BUF","encodeMethod","encodeProperties","Properties","props","content","isBuffer","TypeError","mframe","pframe","methodHeaderLen","bodyLen","FRAME_OVERHEAD","allLen","all","allocUnsafe","offset","copy","makeBodyFrame","both","body","writeResult","maxBody","slice","bodyFrame","parseFrame","decodeFrame","incoming","read","concat","ws","wrap","_write","chunk","encoding","callback","CONNECTION_FORCED","module","exports"],"sources":["/home/jp228/Desktop/frontend/node_modules/amqplib/lib/connection.js"],"sourcesContent":["//\n//\n//\n\n'use strict';\n\nvar defs = require('./defs');\nvar constants = defs.constants;\nvar frame = require('./frame');\nvar HEARTBEAT = frame.HEARTBEAT;\nvar Mux = require('./mux').Mux;\n\nvar Duplex =\n  require('stream').Duplex ||\n  require('readable-stream/duplex');\nvar EventEmitter = require('events').EventEmitter;\nvar Heart = require('./heartbeat').Heart;\n\nvar methodName = require('./format').methodName;\nvar closeMsg = require('./format').closeMessage;\nvar inspect = require('./format').inspect;\n\nvar BitSet = require('./bitset').BitSet;\nvar inherits = require('util').inherits;\nvar fmt = require('util').format;\nvar PassThrough = require('stream').PassThrough ||\n  require('readable-stream/passthrough');\nvar IllegalOperationError = require('./error').IllegalOperationError;\nvar stackCapture = require('./error').stackCapture;\n\n// High-water mark for channel write buffers, in 'objects' (which are\n// encoded frames as buffers).\nvar DEFAULT_WRITE_HWM = 1024;\n// If all the frames of a message (method, properties, content) total\n// to less than this, copy them into a single buffer and write it all\n// at once. Note that this is less than the minimum frame size: if it\n// was greater, we might have to fragment the content.\nvar SINGLE_CHUNK_THRESHOLD = 2048;\n\nfunction Connection(underlying) {\n  EventEmitter.call( this );\n  var stream = this.stream = wrapStream(underlying);\n  this.muxer = new Mux(stream);\n\n  // frames\n  this.rest = Buffer.alloc(0);\n  this.frameMax = constants.FRAME_MIN_SIZE;\n  this.sentSinceLastCheck = false;\n  this.recvSinceLastCheck = false;\n\n  this.expectSocketClose = false;\n  this.freeChannels = new BitSet();\n  this.channels = [{channel: {accept: channel0(this)},\n                    buffer: underlying}];\n}\ninherits(Connection, EventEmitter);\n\nvar C = Connection.prototype;\n\n// Usual frame accept mode\nfunction mainAccept(frame) {\n  var rec = this.channels[frame.channel];\n  if (rec) { return rec.channel.accept(frame); }\n  // NB CHANNEL_ERROR may not be right, but I don't know what is ..\n  else\n    this.closeWithError(\n      fmt('Frame on unknown channel %d', frame.channel),\n      constants.CHANNEL_ERROR,\n      new Error(fmt(\"Frame on unknown channel: %s\",\n                    inspect(frame, false))));\n}\n\n// Handle anything that comes through on channel 0, that's the\n// connection control channel. This is only used once mainAccept is\n// installed as the frame handler, after the opening handshake.\nfunction channel0(connection) {\n  return function(f) {\n    // Once we get a 'close', we know 1. we'll get no more frames, and\n    // 2. anything we send except close, or close-ok, will be\n    // ignored. If we already sent 'close', this won't be invoked since\n    // we're already in closing mode; if we didn't well we're not going\n    // to send it now are we.\n    if (f === HEARTBEAT); // ignore; it's already counted as activity\n                          // on the socket, which is its purpose\n    else if (f.id === defs.ConnectionClose) {\n      // Oh. OK. I guess we're done here then.\n      connection.sendMethod(0, defs.ConnectionCloseOk, {});\n      var emsg = fmt('Connection closed: %s', closeMsg(f));\n      var s = stackCapture(emsg);\n      var e = new Error(emsg);\n      e.code = f.fields.replyCode;\n      if (isFatalError(e)) {\n        connection.emit('error', e);\n      }\n      connection.toClosed(s, e);\n    }\n    else if (f.id === defs.ConnectionBlocked) {\n      connection.emit('blocked', f.fields.reason);\n    }\n    else if (f.id === defs.ConnectionUnblocked) {\n      connection.emit('unblocked');\n    }\n    else {\n      connection.closeWithError(\n        fmt(\"Unexpected frame on channel 0\"),\n        constants.UNEXPECTED_FRAME,\n        new Error(fmt(\"Unexpected frame on channel 0: %s\",\n                      inspect(f, false))));\n    }\n  };\n}\n\n// This changed between versions, as did the codec, methods, etc. AMQP\n// 0-9-1 is fairly similar to 0.8, but better, and nothing implements\n// 0.8 that doesn't implement 0-9-1. In other words, it doesn't make\n// much sense to generalise here.\nC.sendProtocolHeader = function() {\n  this.sendBytes(frame.PROTOCOL_HEADER);\n};\n\n/*\n  The frighteningly complicated opening protocol (spec section 2.2.4):\n\n     Client -> Server\n\n       protocol header ->\n         <- start\n       start-ok ->\n     .. next two zero or more times ..\n         <- secure\n       secure-ok ->\n         <- tune\n       tune-ok ->\n       open ->\n         <- open-ok\n\nIf I'm only supporting SASL's PLAIN mechanism (which I am for the time\nbeing), it gets a bit easier since the server won't in general send\nback a `secure`, it'll just send `tune` after the `start-ok`.\n(SASL PLAIN: http://tools.ietf.org/html/rfc4616)\n\n*/\n\nC.open = function(allFields, openCallback0) {\n  var self = this;\n  var openCallback = openCallback0 || function() {};\n\n  // This is where we'll put our negotiated values\n  var tunedOptions = Object.create(allFields);\n\n  function wait(k) {\n    self.step(function(err, frame) {\n      if (err !== null) bail(err);\n      else if (frame.channel !== 0) {\n        bail(new Error(\n          fmt(\"Frame on channel != 0 during handshake: %s\",\n              inspect(frame, false))));\n      }\n      else k(frame);\n    });\n  }\n\n  function expect(Method, k) {\n    wait(function(frame) {\n      if (frame.id === Method) k(frame);\n      else {\n        bail(new Error(\n          fmt(\"Expected %s; got %s\",\n              methodName(Method), inspect(frame, false))));\n      }\n    });\n  }\n\n  function bail(err) {\n    openCallback(err);\n  }\n\n  function send(Method) {\n    // This can throw an exception if there's some problem with the\n    // options; e.g., something is a string instead of a number.\n    self.sendMethod(0, Method, tunedOptions);\n  }\n\n  function negotiate(server, desired) {\n    // We get sent values for channelMax, frameMax and heartbeat,\n    // which we may accept or lower (subject to a minimum for\n    // frameMax, but we'll leave that to the server to enforce). In\n    // all cases, `0` really means \"no limit\", or rather the highest\n    // value in the encoding, e.g., unsigned short for channelMax.\n    if (server === 0 || desired === 0) {\n      // i.e., whichever places a limit, if either\n      return Math.max(server, desired);\n    }\n    else {\n      return Math.min(server, desired);\n    }\n  }\n\n  function onStart(start) {\n    var mechanisms = start.fields.mechanisms.toString().split(' ');\n    if (mechanisms.indexOf(allFields.mechanism) < 0) {\n      bail(new Error(fmt('SASL mechanism %s is not provided by the server',\n                         allFields.mechanism)));\n      return;\n    }\n    self.serverProperties = start.fields.serverProperties;\n    try {\n      send(defs.ConnectionStartOk);\n    } catch (err) {\n      bail(err);\n      return;\n    }\n    wait(afterStartOk);\n  }\n\n  function afterStartOk(reply) {\n    switch (reply.id) {\n    case defs.ConnectionSecure:\n      bail(new Error(\n        \"Wasn't expecting to have to go through secure\"));\n      break;\n    case defs.ConnectionClose:\n      bail(new Error(fmt(\"Handshake terminated by server: %s\",\n                         closeMsg(reply))));\n      break;\n    case defs.ConnectionTune:\n      var fields = reply.fields;\n      tunedOptions.frameMax =\n        negotiate(fields.frameMax, allFields.frameMax);\n      tunedOptions.channelMax =\n        negotiate(fields.channelMax, allFields.channelMax);\n      tunedOptions.heartbeat =\n        negotiate(fields.heartbeat, allFields.heartbeat);\n      try {\n        send(defs.ConnectionTuneOk);\n        send(defs.ConnectionOpen);\n      } catch (err) {\n        bail(err);\n        return;\n      }\n      expect(defs.ConnectionOpenOk, onOpenOk);\n      break;\n    default:\n      bail(new Error(\n        fmt(\"Expected connection.secure, connection.close, \" +\n            \"or connection.tune during handshake; got %s\",\n            inspect(reply, false))));\n      break;\n    }\n  }\n\n  function onOpenOk(openOk) {\n    // Impose the maximum of the encoded value, if the negotiated\n    // value is zero, meaning \"no, no limits\"\n    self.channelMax = tunedOptions.channelMax || 0xffff;\n    self.frameMax = tunedOptions.frameMax || 0xffffffff;\n    // 0 means \"no heartbeat\", rather than \"maximum period of\n    // heartbeating\"\n    self.heartbeat = tunedOptions.heartbeat;\n    self.heartbeater = self.startHeartbeater();\n    self.accept = mainAccept;\n    succeed(openOk);\n  }\n\n  // If the server closes the connection, it's probably because of\n  // something we did\n  function endWhileOpening(err) {\n    bail(err || new Error('Socket closed abruptly ' +\n                          'during opening handshake'));\n  }\n\n  this.stream.on('end', endWhileOpening);\n  this.stream.on('error', endWhileOpening);\n\n  function succeed(ok) {\n    self.stream.removeListener('end', endWhileOpening);\n    self.stream.removeListener('error', endWhileOpening);\n    self.stream.on('error', self.onSocketError.bind(self));\n    self.stream.on('end', self.onSocketError.bind(\n      self, new Error('Unexpected close')));\n    self.on('frameError', self.onSocketError.bind(self));\n    self.acceptLoop();\n    openCallback(null, ok);\n  }\n\n  // Now kick off the handshake by prompting the server\n  this.sendProtocolHeader();\n  expect(defs.ConnectionStart, onStart);\n};\n\n// Closing things: AMQP has a closing handshake that applies to\n// closing both connects and channels. As the initiating party, I send\n// Close, then ignore all frames until I see either CloseOK --\n// which signifies that the other party has seen the Close and shut\n// the connection or channel down, so it's fine to free resources; or\n// Close, which means the other party also wanted to close the\n// whatever, and I should send CloseOk so it can free resources,\n// then go back to waiting for the CloseOk. If I receive a Close\n// out of the blue, I should throw away any unsent frames (they will\n// be ignored anyway) and send CloseOk, then clean up resources. In\n// general, Close out of the blue signals an error (or a forced\n// closure, which may as well be an error).\n//\n//  RUNNING [1] --- send Close ---> Closing [2] ---> recv Close --+\n//     |                               |                         [3]\n//     |                               +------ send CloseOk ------+\n//  recv Close                   recv CloseOk\n//     |                               |\n//     V                               V\n//  Ended [4] ---- send CloseOk ---> Closed [5]\n//\n// [1] All frames accepted; getting a Close frame from the server\n// moves to Ended; client may initiate a close by sending Close\n// itself.\n// [2] Client has initiated a close; only CloseOk or (simulataneously\n// sent) Close is accepted.\n// [3] Simultaneous close\n// [4] Server won't send any more frames; accept no more frames, send\n// CloseOk.\n// [5] Fully closed, client will send no more, server will send no\n// more. Signal 'close' or 'error'.\n//\n// There are two signalling mechanisms used in the API. The first is\n// that calling `close` will return a promise, that will either\n// resolve once the connection or channel is cleanly shut down, or\n// will reject if the shutdown times out.\n//\n// The second is the 'close' and 'error' events. These are\n// emitted as above. The events will fire *before* promises are\n// resolved.\n\n// Close the connection without even giving a reason. Typical.\nC.close = function(closeCallback) {\n  var k = closeCallback && function() { closeCallback(null); };\n  this.closeBecause(\"Cheers, thanks\", constants.REPLY_SUCCESS, k);\n};\n\n// Close with a reason and a 'code'. I'm pretty sure RabbitMQ totally\n// ignores these; maybe it logs them. The continuation will be invoked\n// when the CloseOk has been received, and before the 'close' event.\nC.closeBecause = function(reason, code, k) {\n  this.sendMethod(0, defs.ConnectionClose, {\n    replyText: reason,\n    replyCode: code,\n    methodId: 0, classId: 0\n  });\n  var s = stackCapture('closeBecause called: ' + reason);\n  this.toClosing(s, k);\n};\n\nC.closeWithError = function(reason, code, error) {\n  this.emit('error', error);\n  this.closeBecause(reason, code);\n};\n\nC.onSocketError = function(err) {\n  if (!this.expectSocketClose) {\n    // forestall any more calls to onSocketError, since we're signed\n    // up for `'error'` *and* `'end'`\n    this.expectSocketClose = true;\n    this.emit('error', err);\n    var s = stackCapture('Socket error');\n    this.toClosed(s, err);\n  }\n};\n\nfunction invalidOp(msg, stack) {\n  return function() {\n    throw new IllegalOperationError(msg, stack);\n  };\n}\n\nfunction invalidateSend(conn, msg, stack) {\n  conn.sendMethod = conn.sendContent = conn.sendMessage =\n    invalidOp(msg, stack);\n}\n\n// A close has been initiated. Repeat: a close has been initiated.\n// This means we should not send more frames, anyway they will be\n// ignored. We also have to shut down all the channels.\nC.toClosing = function(capturedStack, k) {\n  var send = this.sendMethod.bind(this);\n\n  this.accept = function(f) {\n    if (f.id === defs.ConnectionCloseOk) {\n      if (k) k();\n      var s = stackCapture('ConnectionCloseOk received');\n      this.toClosed(s, undefined);\n    }\n    else if (f.id === defs.ConnectionClose) {\n      send(0, defs.ConnectionCloseOk, {});\n    }\n    // else ignore frame\n  };\n  invalidateSend(this, 'Connection closing', capturedStack);\n};\n\nC._closeChannels = function(capturedStack) {\n  for (var i = 1; i < this.channels.length; i++) {\n    var ch = this.channels[i];\n    if (ch !== null) {\n      ch.channel.toClosed(capturedStack); // %%% or with an error? not clear\n    }\n  }\n};\n\n// A close has been confirmed. Cease all communication.\nC.toClosed = function(capturedStack, maybeErr) {\n  this._closeChannels(capturedStack);\n  var info = fmt('Connection closed (%s)',\n                 (maybeErr) ? maybeErr.toString() : 'by client');\n  // Tidy up, invalidate enverything, dynamite the bridges.\n  invalidateSend(this, info, capturedStack);\n  this.accept = invalidOp(info, capturedStack);\n  this.close = function(cb) {\n    cb && cb(new IllegalOperationError(info, capturedStack));\n  };\n  if (this.heartbeater) this.heartbeater.clear();\n  // This is certainly true now, if it wasn't before\n  this.expectSocketClose = true;\n  this.stream.end();\n  this.emit('close', maybeErr);\n};\n\n// ===\n\nC.startHeartbeater = function() {\n  if (this.heartbeat === 0) return null;\n  else {\n    var self = this;\n    var hb = new Heart(this.heartbeat,\n                       this.checkSend.bind(this),\n                       this.checkRecv.bind(this));\n    hb.on('timeout', function() {\n      var hberr = new Error(\"Heartbeat timeout\");\n      self.emit('error', hberr);\n      var s = stackCapture('Heartbeat timeout');\n      self.toClosed(s, hberr);\n    });\n    hb.on('beat', function() {\n      self.sendHeartbeat();\n    });\n    return hb;\n  }\n};\n\n// I use an array to keep track of the channels, rather than an\n// object. The channel identifiers are numbers, and allocated by the\n// connection. If I try to allocate low numbers when they are\n// available (which I do, by looking from the start of the bitset),\n// this ought to keep the array small, and out of 'sparse array\n// storage'. I also set entries to null, rather than deleting them, in\n// the expectation that the next channel allocation will fill the slot\n// again rather than growing the array. See\n// http://www.html5rocks.com/en/tutorials/speed/v8/\nC.freshChannel = function(channel, options) {\n  var next = this.freeChannels.nextClearBit(1);\n  if (next < 0 || next > this.channelMax)\n    throw new Error(\"No channels left to allocate\");\n  this.freeChannels.set(next);\n\n  var hwm = (options && options.highWaterMark) || DEFAULT_WRITE_HWM;\n  var writeBuffer = new PassThrough({\n    objectMode: true, highWaterMark: hwm\n  });\n  this.channels[next] = {channel: channel, buffer: writeBuffer};\n  writeBuffer.on('drain', function() {\n    channel.onBufferDrain();\n  });\n  this.muxer.pipeFrom(writeBuffer);\n  return next;\n};\n\nC.releaseChannel = function(channel) {\n  this.freeChannels.clear(channel);\n  var buffer = this.channels[channel].buffer;\n  buffer.end(); // will also cause it to be unpiped\n  this.channels[channel] = null;\n};\n\nC.acceptLoop = function() {\n  var self = this;\n\n  function go() {\n    try {\n      var f; while (f = self.recvFrame()) self.accept(f);\n    }\n    catch (e) {\n      self.emit('frameError', e);\n    }\n  }\n  self.stream.on('readable', go);\n  go();\n};\n\nC.step = function(cb) {\n  var self = this;\n  function recv() {\n    var f;\n    try {\n      f = self.recvFrame();\n    }\n    catch (e) {\n      cb(e, null);\n      return;\n    }\n    if (f) cb(null, f);\n    else self.stream.once('readable', recv);\n  }\n  recv();\n};\n\nC.checkSend = function() {\n  var check = this.sentSinceLastCheck;\n  this.sentSinceLastCheck = false;\n  return check;\n}\n\nC.checkRecv = function() {\n  var check = this.recvSinceLastCheck;\n  this.recvSinceLastCheck = false;\n  return check;\n}\n\nC.sendBytes = function(bytes) {\n  this.sentSinceLastCheck = true;\n  this.stream.write(bytes);\n};\n\nC.sendHeartbeat = function() {\n  return this.sendBytes(frame.HEARTBEAT_BUF);\n};\n\nvar encodeMethod = defs.encodeMethod;\nvar encodeProperties = defs.encodeProperties;\n\nC.sendMethod = function(channel, Method, fields) {\n  var frame = encodeMethod(Method, channel, fields);\n  this.sentSinceLastCheck = true;\n  var buffer = this.channels[channel].buffer;\n  return buffer.write(frame);\n};\n\nC.sendMessage = function(channel,\n                         Method, fields,\n                         Properties, props,\n                         content) {\n  if (!Buffer.isBuffer(content))\n    throw new TypeError('content is not a buffer');\n\n  var mframe = encodeMethod(Method, channel, fields);\n  var pframe = encodeProperties(Properties, channel,\n                                content.length, props);\n  var buffer = this.channels[channel].buffer;\n  this.sentSinceLastCheck = true;\n\n  var methodHeaderLen = mframe.length + pframe.length;\n  var bodyLen = (content.length > 0) ?\n    content.length + FRAME_OVERHEAD : 0;\n  var allLen = methodHeaderLen + bodyLen;\n\n  if (allLen < SINGLE_CHUNK_THRESHOLD) {\n    // Use `allocUnsafe` to avoid excessive allocations and CPU usage\n    // from zeroing. The returned Buffer is not zeroed and so must be\n    // completely filled to be used safely.\n    // See https://github.com/amqp-node/amqplib/pull/695\n    var all = Buffer.allocUnsafe(allLen);\n    var offset = mframe.copy(all, 0);\n    offset += pframe.copy(all, offset);\n\n    if (bodyLen > 0)\n      makeBodyFrame(channel, content).copy(all, offset);\n    return buffer.write(all);\n  }\n  else {\n    if (methodHeaderLen < SINGLE_CHUNK_THRESHOLD) {\n      // Use `allocUnsafe` to avoid excessive allocations and CPU usage\n      // from zeroing. The returned Buffer is not zeroed and so must be\n      // completely filled to be used safely.\n      // See https://github.com/amqp-node/amqplib/pull/695\n      var both = Buffer.allocUnsafe(methodHeaderLen);\n      var offset = mframe.copy(both, 0);\n      pframe.copy(both, offset);\n      buffer.write(both);\n    }\n    else {\n      buffer.write(mframe);\n      buffer.write(pframe);\n    }\n    return this.sendContent(channel, content);\n  }\n};\n\nvar FRAME_OVERHEAD = defs.FRAME_OVERHEAD;\nvar makeBodyFrame = frame.makeBodyFrame;\n\nC.sendContent = function(channel, body) {\n  if (!Buffer.isBuffer(body)) {\n    throw new TypeError(fmt(\"Expected buffer; got %s\", body));\n  }\n  var writeResult = true;\n  var buffer = this.channels[channel].buffer;\n\n  var maxBody = this.frameMax - FRAME_OVERHEAD;\n\n  for (var offset = 0; offset < body.length; offset += maxBody) {\n    var end = offset + maxBody;\n    var slice = (end > body.length) ? body.slice(offset) : body.slice(offset, end);\n    var bodyFrame = makeBodyFrame(channel, slice);\n    writeResult = buffer.write(bodyFrame);\n  }\n  this.sentSinceLastCheck = true;\n  return writeResult;\n};\n\nvar parseFrame = frame.parseFrame;\nvar decodeFrame = frame.decodeFrame;\n\nC.recvFrame = function() {\n  // %%% identifying invariants might help here?\n  var frame = parseFrame(this.rest, this.frameMax);\n\n  if (!frame) {\n    var incoming = this.stream.read();\n    if (incoming === null) {\n      return false;\n    }\n    else {\n      this.recvSinceLastCheck = true;\n      this.rest = Buffer.concat([this.rest, incoming]);\n      return this.recvFrame();\n    }\n  }\n  else {\n    this.rest = frame.rest;\n    return decodeFrame(frame);\n  }\n};\n\nfunction wrapStream(s) {\n  if (s instanceof Duplex) return s;\n  else {\n    var ws = new Duplex();\n    ws.wrap(s); //wraps the readable side of things\n    ws._write = function(chunk, encoding, callback) {\n      return s.write(chunk, encoding, callback);\n    };\n    return ws;\n  }\n}\n\nfunction isFatalError(error) {\n  switch (error && error.code) {\n  case defs.constants.CONNECTION_FORCED:\n  case defs.constants.REPLY_SUCCESS:\n    return false;\n  default:\n    return true;\n  }\n}\n\nmodule.exports.Connection = Connection;\nmodule.exports.isFatalError = isFatalError;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}