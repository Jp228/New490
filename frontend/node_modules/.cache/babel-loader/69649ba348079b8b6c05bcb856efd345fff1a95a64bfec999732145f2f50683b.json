{"ast":null,"code":"/* eslint-disable complexity,max-statements */\n/**\n * file.js: Transport for outputting to a local log file.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst asyncSeries = require('async/series');\nconst zlib = require('zlib');\nconst {\n  MESSAGE\n} = require('triple-beam');\nconst {\n  Stream,\n  PassThrough\n} = require('readable-stream');\nconst TransportStream = require('winston-transport');\nconst debug = require('@dabh/diagnostics')('winston:file');\nconst os = require('os');\nconst tailFile = require('../tail-file');\n\n/**\n * Transport for outputting to a local log file.\n * @type {File}\n * @extends {TransportStream}\n */\nmodule.exports = class File extends TransportStream {\n  /**\n   * Constructor function for the File transport object responsible for\n   * persisting log messages and metadata to one or more files.\n   * @param {Object} options - Options for this instance.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    // Expose the name of this Transport on the prototype.\n    this.name = options.name || 'file';\n\n    // Helper function which throws an `Error` in the event that any of the\n    // rest of the arguments is present in `options`.\n    function throwIf(target, ...args) {\n      args.slice(1).forEach(name => {\n        if (options[name]) {\n          throw new Error(`Cannot set ${name} and ${target} together`);\n        }\n      });\n    }\n\n    // Setup the base stream that always gets piped to to handle buffering.\n    this._stream = new PassThrough();\n    this._stream.setMaxListeners(30);\n\n    // Bind this context for listener methods.\n    this._onError = this._onError.bind(this);\n    if (options.filename || options.dirname) {\n      throwIf('filename or dirname', 'stream');\n      this._basename = this.filename = options.filename ? path.basename(options.filename) : 'winston.log';\n      this.dirname = options.dirname || path.dirname(options.filename);\n      this.options = options.options || {\n        flags: 'a'\n      };\n    } else if (options.stream) {\n      // eslint-disable-next-line no-console\n      console.warn('options.stream will be removed in winston@4. Use winston.transports.Stream');\n      throwIf('stream', 'filename', 'maxsize');\n      this._dest = this._stream.pipe(this._setupStream(options.stream));\n      this.dirname = path.dirname(this._dest.path);\n      // We need to listen for drain events when write() returns false. This\n      // can make node mad at times.\n    } else {\n      throw new Error('Cannot log to file without filename or stream.');\n    }\n    this.maxsize = options.maxsize || null;\n    this.rotationFormat = options.rotationFormat || false;\n    this.zippedArchive = options.zippedArchive || false;\n    this.maxFiles = options.maxFiles || null;\n    this.eol = typeof options.eol === 'string' ? options.eol : os.EOL;\n    this.tailable = options.tailable || false;\n    this.lazy = options.lazy || false;\n\n    // Internal state variables representing the number of files this instance\n    // has created and the current size (in bytes) of the current logfile.\n    this._size = 0;\n    this._pendingSize = 0;\n    this._created = 0;\n    this._drain = false;\n    this._opening = false;\n    this._ending = false;\n    this._fileExist = false;\n    if (this.dirname) this._createLogDirIfNotExist(this.dirname);\n    if (!this.lazy) this.open();\n  }\n  finishIfEnding() {\n    if (this._ending) {\n      if (this._opening) {\n        this.once('open', () => {\n          this._stream.once('finish', () => this.emit('finish'));\n          setImmediate(() => this._stream.end());\n        });\n      } else {\n        this._stream.once('finish', () => this.emit('finish'));\n        setImmediate(() => this._stream.end());\n      }\n    }\n  }\n\n  /**\n   * Core logging method exposed to Winston. Metadata is optional.\n   * @param {Object} info - TODO: add param description.\n   * @param {Function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  log(info, callback = () => {}) {\n    // Remark: (jcrugzz) What is necessary about this callback(null, true) now\n    // when thinking about 3.x? Should silent be handled in the base\n    // TransportStream _write method?\n    if (this.silent) {\n      callback();\n      return true;\n    }\n\n    // Output stream buffer is full and has asked us to wait for the drain event\n    if (this._drain) {\n      this._stream.once('drain', () => {\n        this._drain = false;\n        this.log(info, callback);\n      });\n      return;\n    }\n    if (this._rotate) {\n      this._stream.once('rotate', () => {\n        this._rotate = false;\n        this.log(info, callback);\n      });\n      return;\n    }\n    if (this.lazy) {\n      if (!this._fileExist) {\n        if (!this._opening) {\n          this.open();\n        }\n        this.once('open', () => {\n          this._fileExist = true;\n          this.log(info, callback);\n          return;\n        });\n        return;\n      }\n      if (this._needsNewFile(this._pendingSize)) {\n        this._dest.once('close', () => {\n          if (!this._opening) {\n            this.open();\n          }\n          this.once('open', () => {\n            this.log(info, callback);\n            return;\n          });\n          return;\n        });\n        return;\n      }\n    }\n\n    // Grab the raw string and append the expected EOL.\n    const output = `${info[MESSAGE]}${this.eol}`;\n    const bytes = Buffer.byteLength(output);\n\n    // After we have written to the PassThrough check to see if we need\n    // to rotate to the next file.\n    //\n    // Remark: This gets called too early and does not depict when data\n    // has been actually flushed to disk.\n    function logged() {\n      this._size += bytes;\n      this._pendingSize -= bytes;\n      debug('logged %s %s', this._size, output);\n      this.emit('logged', info);\n\n      // Do not attempt to rotate files while rotating\n      if (this._rotate) {\n        return;\n      }\n\n      // Do not attempt to rotate files while opening\n      if (this._opening) {\n        return;\n      }\n\n      // Check to see if we need to end the stream and create a new one.\n      if (!this._needsNewFile()) {\n        return;\n      }\n      if (this.lazy) {\n        this._endStream(() => {\n          this.emit('fileclosed');\n        });\n        return;\n      }\n\n      // End the current stream, ensure it flushes and create a new one.\n      // This could potentially be optimized to not run a stat call but its\n      // the safest way since we are supporting `maxFiles`.\n      this._rotate = true;\n      this._endStream(() => this._rotateFile());\n    }\n\n    // Keep track of the pending bytes being written while files are opening\n    // in order to properly rotate the PassThrough this._stream when the file\n    // eventually does open.\n    this._pendingSize += bytes;\n    if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {\n      this.rotatedWhileOpening = true;\n    }\n    const written = this._stream.write(output, logged.bind(this));\n    if (!written) {\n      this._drain = true;\n      this._stream.once('drain', () => {\n        this._drain = false;\n        callback();\n      });\n    } else {\n      callback(); // eslint-disable-line callback-return\n    }\n    debug('written', written, this._drain);\n    this.finishIfEnding();\n    return written;\n  }\n\n  /**\n   * Query the transport. Options object is optional.\n   * @param {Object} options - Loggly-like query options for this instance.\n   * @param {function} callback - Continuation to respond to when complete.\n   * TODO: Refactor me.\n   */\n  query(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = normalizeQuery(options);\n    const file = path.join(this.dirname, this.filename);\n    let buff = '';\n    let results = [];\n    let row = 0;\n    const stream = fs.createReadStream(file, {\n      encoding: 'utf8'\n    });\n    stream.on('error', err => {\n      if (stream.readable) {\n        stream.destroy();\n      }\n      if (!callback) {\n        return;\n      }\n      return err.code !== 'ENOENT' ? callback(err) : callback(null, results);\n    });\n    stream.on('data', data => {\n      data = (buff + data).split(/\\n+/);\n      const l = data.length - 1;\n      let i = 0;\n      for (; i < l; i++) {\n        if (!options.start || row >= options.start) {\n          add(data[i]);\n        }\n        row++;\n      }\n      buff = data[l];\n    });\n    stream.on('close', () => {\n      if (buff) {\n        add(buff, true);\n      }\n      if (options.order === 'desc') {\n        results = results.reverse();\n      }\n\n      // eslint-disable-next-line callback-return\n      if (callback) callback(null, results);\n    });\n    function add(buff, attempt) {\n      try {\n        const log = JSON.parse(buff);\n        if (check(log)) {\n          push(log);\n        }\n      } catch (e) {\n        if (!attempt) {\n          stream.emit('error', e);\n        }\n      }\n    }\n    function push(log) {\n      if (options.rows && results.length >= options.rows && options.order !== 'desc') {\n        if (stream.readable) {\n          stream.destroy();\n        }\n        return;\n      }\n      if (options.fields) {\n        log = options.fields.reduce((obj, key) => {\n          obj[key] = log[key];\n          return obj;\n        }, {});\n      }\n      if (options.order === 'desc') {\n        if (results.length >= options.rows) {\n          results.shift();\n        }\n      }\n      results.push(log);\n    }\n    function check(log) {\n      if (!log) {\n        return;\n      }\n      if (typeof log !== 'object') {\n        return;\n      }\n      const time = new Date(log.timestamp);\n      if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {\n        return;\n      }\n      return true;\n    }\n    function normalizeQuery(options) {\n      options = options || {};\n\n      // limit\n      options.rows = options.rows || options.limit || 10;\n\n      // starting row offset\n      options.start = options.start || 0;\n\n      // now\n      options.until = options.until || new Date();\n      if (typeof options.until !== 'object') {\n        options.until = new Date(options.until);\n      }\n\n      // now - 24\n      options.from = options.from || options.until - 24 * 60 * 60 * 1000;\n      if (typeof options.from !== 'object') {\n        options.from = new Date(options.from);\n      }\n\n      // 'asc' or 'desc'\n      options.order = options.order || 'desc';\n      return options;\n    }\n  }\n\n  /**\n   * Returns a log stream for this transport. Options object is optional.\n   * @param {Object} options - Stream options for this instance.\n   * @returns {Stream} - TODO: add return description.\n   * TODO: Refactor me.\n   */\n  stream(options = {}) {\n    const file = path.join(this.dirname, this.filename);\n    const stream = new Stream();\n    const tail = {\n      file,\n      start: options.start\n    };\n    stream.destroy = tailFile(tail, (err, line) => {\n      if (err) {\n        return stream.emit('error', err);\n      }\n      try {\n        stream.emit('data', line);\n        line = JSON.parse(line);\n        stream.emit('log', line);\n      } catch (e) {\n        stream.emit('error', e);\n      }\n    });\n    return stream;\n  }\n\n  /**\n   * Checks to see the filesize of.\n   * @returns {undefined}\n   */\n  open() {\n    // If we do not have a filename then we were passed a stream and\n    // don't need to keep track of size.\n    if (!this.filename) return;\n    if (this._opening) return;\n    this._opening = true;\n\n    // Stat the target file to get the size and create the stream.\n    this.stat((err, size) => {\n      if (err) {\n        return this.emit('error', err);\n      }\n      debug('stat done: %s { size: %s }', this.filename, size);\n      this._size = size;\n      this._dest = this._createStream(this._stream);\n      this._opening = false;\n      this.once('open', () => {\n        if (this._stream.eventNames().includes('rotate')) {\n          this._stream.emit('rotate');\n        } else {\n          this._rotate = false;\n        }\n      });\n    });\n  }\n\n  /**\n   * Stat the file and assess information in order to create the proper stream.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  stat(callback) {\n    const target = this._getFile();\n    const fullpath = path.join(this.dirname, target);\n    fs.stat(fullpath, (err, stat) => {\n      if (err && err.code === 'ENOENT') {\n        debug('ENOENT ok', fullpath);\n        // Update internally tracked filename with the new target name.\n        this.filename = target;\n        return callback(null, 0);\n      }\n      if (err) {\n        debug(`err ${err.code} ${fullpath}`);\n        return callback(err);\n      }\n      if (!stat || this._needsNewFile(stat.size)) {\n        // If `stats.size` is greater than the `maxsize` for this\n        // instance then try again.\n        return this._incFile(() => this.stat(callback));\n      }\n\n      // Once we have figured out what the filename is, set it\n      // and return the size.\n      this.filename = target;\n      callback(null, stat.size);\n    });\n  }\n\n  /**\n   * Closes the stream associated with this instance.\n   * @param {function} cb - TODO: add param description.\n   * @returns {undefined}\n   */\n  close(cb) {\n    if (!this._stream) {\n      return;\n    }\n    this._stream.end(() => {\n      if (cb) {\n        cb(); // eslint-disable-line callback-return\n      }\n      this.emit('flush');\n      this.emit('closed');\n    });\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {number} size - TODO: add param description.\n   * @returns {undefined}\n   */\n  _needsNewFile(size) {\n    size = size || this._size;\n    return this.maxsize && size >= this.maxsize;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Error} err - TODO: add param description.\n   * @returns {undefined}\n   */\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Stream} stream - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  _setupStream(stream) {\n    stream.on('error', this._onError);\n    return stream;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Stream} stream - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  _cleanupStream(stream) {\n    stream.removeListener('error', this._onError);\n    stream.destroy();\n    return stream;\n  }\n\n  /**\n   * TODO: add method description.\n   */\n  _rotateFile() {\n    this._incFile(() => this.open());\n  }\n\n  /**\n   * Unpipe from the stream that has been marked as full and end it so it\n   * flushes to disk.\n   *\n   * @param {function} callback - Callback for when the current file has closed.\n   * @private\n   */\n  _endStream(callback = () => {}) {\n    if (this._dest) {\n      this._stream.unpipe(this._dest);\n      this._dest.end(() => {\n        this._cleanupStream(this._dest);\n        callback();\n      });\n    } else {\n      callback(); // eslint-disable-line callback-return\n    }\n  }\n\n  /**\n   * Returns the WritableStream for the active file on this instance. If we\n   * should gzip the file then a zlib stream is returned.\n   *\n   * @param {ReadableStream} source –PassThrough to pipe to the file when open.\n   * @returns {WritableStream} Stream that writes to disk for the active file.\n   */\n  _createStream(source) {\n    const fullpath = path.join(this.dirname, this.filename);\n    debug('create stream start', fullpath, this.options);\n    const dest = fs.createWriteStream(fullpath, this.options)\n    // TODO: What should we do with errors here?\n    .on('error', err => debug(err)).on('close', () => debug('close', dest.path, dest.bytesWritten)).on('open', () => {\n      debug('file open ok', fullpath);\n      this.emit('open', fullpath);\n      source.pipe(dest);\n\n      // If rotation occured during the open operation then we immediately\n      // start writing to a new PassThrough, begin opening the next file\n      // and cleanup the previous source and dest once the source has drained.\n      if (this.rotatedWhileOpening) {\n        this._stream = new PassThrough();\n        this._stream.setMaxListeners(30);\n        this._rotateFile();\n        this.rotatedWhileOpening = false;\n        this._cleanupStream(dest);\n        source.end();\n      }\n    });\n    debug('create stream ok', fullpath);\n    return dest;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  _incFile(callback) {\n    debug('_incFile', this.filename);\n    const ext = path.extname(this._basename);\n    const basename = path.basename(this._basename, ext);\n    const tasks = [];\n    if (this.zippedArchive) {\n      tasks.push(function (cb) {\n        const num = this._created > 0 && !this.tailable ? this._created : '';\n        this._compressFile(path.join(this.dirname, `${basename}${num}${ext}`), path.join(this.dirname, `${basename}${num}${ext}.gz`), cb);\n      }.bind(this));\n    }\n    tasks.push(function (cb) {\n      if (!this.tailable) {\n        this._created += 1;\n        this._checkMaxFilesIncrementing(ext, basename, cb);\n      } else {\n        this._checkMaxFilesTailable(ext, basename, cb);\n      }\n    }.bind(this));\n    asyncSeries(tasks, callback);\n  }\n\n  /**\n   * Gets the next filename to use for this instance in the case that log\n   * filesizes are being capped.\n   * @returns {string} - TODO: add return description.\n   * @private\n   */\n  _getFile() {\n    const ext = path.extname(this._basename);\n    const basename = path.basename(this._basename, ext);\n    const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;\n\n    // Caveat emptor (indexzero): rotationFormat() was broken by design When\n    // combined with max files because the set of files to unlink is never\n    // stored.\n    return !this.tailable && this._created ? `${basename}${isRotation}${ext}` : `${basename}${ext}`;\n  }\n\n  /**\n   * Increment the number of files created or checked by this instance.\n   * @param {mixed} ext - TODO: add param description.\n   * @param {mixed} basename - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {undefined}\n   * @private\n   */\n  _checkMaxFilesIncrementing(ext, basename, callback) {\n    // Check for maxFiles option and delete file.\n    if (!this.maxFiles || this._created < this.maxFiles) {\n      return setImmediate(callback);\n    }\n    const oldest = this._created - this.maxFiles;\n    const isOldest = oldest !== 0 ? oldest : '';\n    const isZipped = this.zippedArchive ? '.gz' : '';\n    const filePath = `${basename}${isOldest}${ext}${isZipped}`;\n    const target = path.join(this.dirname, filePath);\n    fs.unlink(target, callback);\n  }\n\n  /**\n   * Roll files forward based on integer, up to maxFiles. e.g. if base if\n   * file.log and it becomes oversized, roll to file1.log, and allow file.log\n   * to be re-used. If file is oversized again, roll file1.log to file2.log,\n   * roll file.log to file1.log, and so on.\n   * @param {mixed} ext - TODO: add param description.\n   * @param {mixed} basename - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {undefined}\n   * @private\n   */\n  _checkMaxFilesTailable(ext, basename, callback) {\n    const tasks = [];\n    if (!this.maxFiles) {\n      return;\n    }\n\n    // const isZipped = this.zippedArchive ? '.gz' : '';\n    const isZipped = this.zippedArchive ? '.gz' : '';\n    for (let x = this.maxFiles - 1; x > 1; x--) {\n      tasks.push(function (i, cb) {\n        let fileName = `${basename}${i - 1}${ext}${isZipped}`;\n        const tmppath = path.join(this.dirname, fileName);\n        fs.exists(tmppath, exists => {\n          if (!exists) {\n            return cb(null);\n          }\n          fileName = `${basename}${i}${ext}${isZipped}`;\n          fs.rename(tmppath, path.join(this.dirname, fileName), cb);\n        });\n      }.bind(this, x));\n    }\n    asyncSeries(tasks, () => {\n      fs.rename(path.join(this.dirname, `${basename}${ext}${isZipped}`), path.join(this.dirname, `${basename}1${ext}${isZipped}`), callback);\n    });\n  }\n\n  /**\n   * Compresses src to dest with gzip and unlinks src\n   * @param {string} src - path to source file.\n   * @param {string} dest - path to zipped destination file.\n   * @param {Function} callback - callback called after file has been compressed.\n   * @returns {undefined}\n   * @private\n   */\n  _compressFile(src, dest, callback) {\n    fs.access(src, fs.F_OK, err => {\n      if (err) {\n        return callback();\n      }\n      var gzip = zlib.createGzip();\n      var inp = fs.createReadStream(src);\n      var out = fs.createWriteStream(dest);\n      out.on('finish', () => {\n        fs.unlink(src, callback);\n      });\n      inp.pipe(gzip).pipe(out);\n    });\n  }\n  _createLogDirIfNotExist(dirPath) {\n    /* eslint-disable no-sync */\n    if (!fs.existsSync(dirPath)) {\n      fs.mkdirSync(dirPath, {\n        recursive: true\n      });\n    }\n    /* eslint-enable no-sync */\n  }\n};","map":{"version":3,"names":["fs","require","path","asyncSeries","zlib","MESSAGE","Stream","PassThrough","TransportStream","debug","os","tailFile","module","exports","File","constructor","options","name","throwIf","target","args","slice","forEach","Error","_stream","setMaxListeners","_onError","bind","filename","dirname","_basename","basename","flags","stream","console","warn","_dest","pipe","_setupStream","maxsize","rotationFormat","zippedArchive","maxFiles","eol","EOL","tailable","lazy","_size","_pendingSize","_created","_drain","_opening","_ending","_fileExist","_createLogDirIfNotExist","open","finishIfEnding","once","emit","setImmediate","end","log","info","callback","silent","_rotate","_needsNewFile","output","bytes","Buffer","byteLength","logged","_endStream","_rotateFile","rotatedWhileOpening","written","write","query","normalizeQuery","file","join","buff","results","row","createReadStream","encoding","on","err","readable","destroy","code","data","split","l","length","i","start","add","order","reverse","attempt","JSON","parse","check","push","e","rows","fields","reduce","obj","key","shift","time","Date","timestamp","from","until","level","limit","tail","line","stat","size","_createStream","eventNames","includes","_getFile","fullpath","_incFile","close","cb","_cleanupStream","removeListener","unpipe","source","dest","createWriteStream","bytesWritten","ext","extname","tasks","num","_compressFile","_checkMaxFilesIncrementing","_checkMaxFilesTailable","isRotation","oldest","isOldest","isZipped","filePath","unlink","x","fileName","tmppath","exists","rename","src","access","F_OK","gzip","createGzip","inp","out","dirPath","existsSync","mkdirSync","recursive"],"sources":["/home/jp228/node_modules/winston/lib/winston/transports/file.js"],"sourcesContent":["/* eslint-disable complexity,max-statements */\n/**\n * file.js: Transport for outputting to a local log file.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst asyncSeries = require('async/series');\nconst zlib = require('zlib');\nconst { MESSAGE } = require('triple-beam');\nconst { Stream, PassThrough } = require('readable-stream');\nconst TransportStream = require('winston-transport');\nconst debug = require('@dabh/diagnostics')('winston:file');\nconst os = require('os');\nconst tailFile = require('../tail-file');\n\n/**\n * Transport for outputting to a local log file.\n * @type {File}\n * @extends {TransportStream}\n */\nmodule.exports = class File extends TransportStream {\n  /**\n   * Constructor function for the File transport object responsible for\n   * persisting log messages and metadata to one or more files.\n   * @param {Object} options - Options for this instance.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    // Expose the name of this Transport on the prototype.\n    this.name = options.name || 'file';\n\n    // Helper function which throws an `Error` in the event that any of the\n    // rest of the arguments is present in `options`.\n    function throwIf(target, ...args) {\n      args.slice(1).forEach(name => {\n        if (options[name]) {\n          throw new Error(`Cannot set ${name} and ${target} together`);\n        }\n      });\n    }\n\n    // Setup the base stream that always gets piped to to handle buffering.\n    this._stream = new PassThrough();\n    this._stream.setMaxListeners(30);\n\n    // Bind this context for listener methods.\n    this._onError = this._onError.bind(this);\n\n    if (options.filename || options.dirname) {\n      throwIf('filename or dirname', 'stream');\n      this._basename = this.filename = options.filename\n        ? path.basename(options.filename)\n        : 'winston.log';\n\n      this.dirname = options.dirname || path.dirname(options.filename);\n      this.options = options.options || { flags: 'a' };\n    } else if (options.stream) {\n      // eslint-disable-next-line no-console\n      console.warn('options.stream will be removed in winston@4. Use winston.transports.Stream');\n      throwIf('stream', 'filename', 'maxsize');\n      this._dest = this._stream.pipe(this._setupStream(options.stream));\n      this.dirname = path.dirname(this._dest.path);\n      // We need to listen for drain events when write() returns false. This\n      // can make node mad at times.\n    } else {\n      throw new Error('Cannot log to file without filename or stream.');\n    }\n\n    this.maxsize = options.maxsize || null;\n    this.rotationFormat = options.rotationFormat || false;\n    this.zippedArchive = options.zippedArchive || false;\n    this.maxFiles = options.maxFiles || null;\n    this.eol = (typeof options.eol === 'string') ? options.eol : os.EOL;\n    this.tailable = options.tailable || false;\n    this.lazy = options.lazy || false;\n\n    // Internal state variables representing the number of files this instance\n    // has created and the current size (in bytes) of the current logfile.\n    this._size = 0;\n    this._pendingSize = 0;\n    this._created = 0;\n    this._drain = false;\n    this._opening = false;\n    this._ending = false;\n    this._fileExist = false;\n\n    if (this.dirname) this._createLogDirIfNotExist(this.dirname);\n    if (!this.lazy) this.open();\n  }\n\n  finishIfEnding() {\n    if (this._ending) {\n      if (this._opening) {\n        this.once('open', () => {\n          this._stream.once('finish', () => this.emit('finish'));\n          setImmediate(() => this._stream.end());\n        });\n      } else {\n        this._stream.once('finish', () => this.emit('finish'));\n        setImmediate(() => this._stream.end());\n      }\n    }\n  }\n\n  /**\n   * Core logging method exposed to Winston. Metadata is optional.\n   * @param {Object} info - TODO: add param description.\n   * @param {Function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  log(info, callback = () => { }) {\n    // Remark: (jcrugzz) What is necessary about this callback(null, true) now\n    // when thinking about 3.x? Should silent be handled in the base\n    // TransportStream _write method?\n    if (this.silent) {\n      callback();\n      return true;\n    }\n\n\n    // Output stream buffer is full and has asked us to wait for the drain event\n    if (this._drain) {\n      this._stream.once('drain', () => {\n        this._drain = false;\n        this.log(info, callback);\n      });\n      return;\n    }\n    if (this._rotate) {\n      this._stream.once('rotate', () => {\n        this._rotate = false;\n        this.log(info, callback);\n      });\n      return;\n    }\n    if (this.lazy) {\n      if (!this._fileExist) {\n        if (!this._opening) {\n          this.open();\n        }\n        this.once('open', () => {\n          this._fileExist = true;\n          this.log(info, callback);\n          return;\n        });\n        return;\n      }\n      if (this._needsNewFile(this._pendingSize)) {\n        this._dest.once('close', () => {\n          if (!this._opening) {\n            this.open();\n          }\n          this.once('open', () => {\n            this.log(info, callback);\n            return;\n          });\n          return;\n        });\n        return;\n      }\n    }\n\n    // Grab the raw string and append the expected EOL.\n    const output = `${info[MESSAGE]}${this.eol}`;\n    const bytes = Buffer.byteLength(output);\n\n    // After we have written to the PassThrough check to see if we need\n    // to rotate to the next file.\n    //\n    // Remark: This gets called too early and does not depict when data\n    // has been actually flushed to disk.\n    function logged() {\n      this._size += bytes;\n      this._pendingSize -= bytes;\n\n      debug('logged %s %s', this._size, output);\n      this.emit('logged', info);\n\n      // Do not attempt to rotate files while rotating\n      if (this._rotate) {\n        return;\n      }\n\n      // Do not attempt to rotate files while opening\n      if (this._opening) {\n        return;\n      }\n\n      // Check to see if we need to end the stream and create a new one.\n      if (!this._needsNewFile()) {\n        return;\n      }\n      if (this.lazy) {\n        this._endStream(() => {this.emit('fileclosed');});\n        return;\n      }\n\n      // End the current stream, ensure it flushes and create a new one.\n      // This could potentially be optimized to not run a stat call but its\n      // the safest way since we are supporting `maxFiles`.\n      this._rotate = true;\n      this._endStream(() => this._rotateFile());\n    }\n\n    // Keep track of the pending bytes being written while files are opening\n    // in order to properly rotate the PassThrough this._stream when the file\n    // eventually does open.\n    this._pendingSize += bytes;\n    if (this._opening\n      && !this.rotatedWhileOpening\n      && this._needsNewFile(this._size + this._pendingSize)) {\n      this.rotatedWhileOpening = true;\n    }\n\n    const written = this._stream.write(output, logged.bind(this));\n    if (!written) {\n      this._drain = true;\n      this._stream.once('drain', () => {\n        this._drain = false;\n        callback();\n      });\n    } else {\n      callback(); // eslint-disable-line callback-return\n    }\n\n    debug('written', written, this._drain);\n\n    this.finishIfEnding();\n\n    return written;\n  }\n\n  /**\n   * Query the transport. Options object is optional.\n   * @param {Object} options - Loggly-like query options for this instance.\n   * @param {function} callback - Continuation to respond to when complete.\n   * TODO: Refactor me.\n   */\n  query(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = normalizeQuery(options);\n    const file = path.join(this.dirname, this.filename);\n    let buff = '';\n    let results = [];\n    let row = 0;\n\n    const stream = fs.createReadStream(file, {\n      encoding: 'utf8'\n    });\n\n    stream.on('error', err => {\n      if (stream.readable) {\n        stream.destroy();\n      }\n      if (!callback) {\n        return;\n      }\n\n      return err.code !== 'ENOENT' ? callback(err) : callback(null, results);\n    });\n\n    stream.on('data', data => {\n      data = (buff + data).split(/\\n+/);\n      const l = data.length - 1;\n      let i = 0;\n\n      for (; i < l; i++) {\n        if (!options.start || row >= options.start) {\n          add(data[i]);\n        }\n        row++;\n      }\n\n      buff = data[l];\n    });\n\n    stream.on('close', () => {\n      if (buff) {\n        add(buff, true);\n      }\n      if (options.order === 'desc') {\n        results = results.reverse();\n      }\n\n      // eslint-disable-next-line callback-return\n      if (callback) callback(null, results);\n    });\n\n    function add(buff, attempt) {\n      try {\n        const log = JSON.parse(buff);\n        if (check(log)) {\n          push(log);\n        }\n      } catch (e) {\n        if (!attempt) {\n          stream.emit('error', e);\n        }\n      }\n    }\n\n    function push(log) {\n      if (\n        options.rows &&\n        results.length >= options.rows &&\n        options.order !== 'desc'\n      ) {\n        if (stream.readable) {\n          stream.destroy();\n        }\n        return;\n      }\n\n      if (options.fields) {\n        log = options.fields.reduce((obj, key) => {\n          obj[key] = log[key];\n          return obj;\n        }, {});\n      }\n\n      if (options.order === 'desc') {\n        if (results.length >= options.rows) {\n          results.shift();\n        }\n      }\n      results.push(log);\n    }\n\n    function check(log) {\n      if (!log) {\n        return;\n      }\n\n      if (typeof log !== 'object') {\n        return;\n      }\n\n      const time = new Date(log.timestamp);\n      if (\n        (options.from && time < options.from) ||\n        (options.until && time > options.until) ||\n        (options.level && options.level !== log.level)\n      ) {\n        return;\n      }\n\n      return true;\n    }\n\n    function normalizeQuery(options) {\n      options = options || {};\n\n      // limit\n      options.rows = options.rows || options.limit || 10;\n\n      // starting row offset\n      options.start = options.start || 0;\n\n      // now\n      options.until = options.until || new Date();\n      if (typeof options.until !== 'object') {\n        options.until = new Date(options.until);\n      }\n\n      // now - 24\n      options.from = options.from || (options.until - (24 * 60 * 60 * 1000));\n      if (typeof options.from !== 'object') {\n        options.from = new Date(options.from);\n      }\n\n      // 'asc' or 'desc'\n      options.order = options.order || 'desc';\n\n      return options;\n    }\n  }\n\n  /**\n   * Returns a log stream for this transport. Options object is optional.\n   * @param {Object} options - Stream options for this instance.\n   * @returns {Stream} - TODO: add return description.\n   * TODO: Refactor me.\n   */\n  stream(options = {}) {\n    const file = path.join(this.dirname, this.filename);\n    const stream = new Stream();\n    const tail = {\n      file,\n      start: options.start\n    };\n\n    stream.destroy = tailFile(tail, (err, line) => {\n      if (err) {\n        return stream.emit('error', err);\n      }\n\n      try {\n        stream.emit('data', line);\n        line = JSON.parse(line);\n        stream.emit('log', line);\n      } catch (e) {\n        stream.emit('error', e);\n      }\n    });\n\n    return stream;\n  }\n\n  /**\n   * Checks to see the filesize of.\n   * @returns {undefined}\n   */\n  open() {\n    // If we do not have a filename then we were passed a stream and\n    // don't need to keep track of size.\n    if (!this.filename) return;\n    if (this._opening) return;\n\n    this._opening = true;\n\n    // Stat the target file to get the size and create the stream.\n    this.stat((err, size) => {\n      if (err) {\n        return this.emit('error', err);\n      }\n      debug('stat done: %s { size: %s }', this.filename, size);\n      this._size = size;\n      this._dest = this._createStream(this._stream);\n      this._opening = false;\n      this.once('open', () => {\n        if (this._stream.eventNames().includes('rotate')) {\n          this._stream.emit('rotate');\n        } else {\n          this._rotate = false;\n        }\n      });\n    });\n  }\n\n  /**\n   * Stat the file and assess information in order to create the proper stream.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  stat(callback) {\n    const target = this._getFile();\n    const fullpath = path.join(this.dirname, target);\n\n    fs.stat(fullpath, (err, stat) => {\n      if (err && err.code === 'ENOENT') {\n        debug('ENOENT ok', fullpath);\n        // Update internally tracked filename with the new target name.\n        this.filename = target;\n        return callback(null, 0);\n      }\n\n      if (err) {\n        debug(`err ${err.code} ${fullpath}`);\n        return callback(err);\n      }\n\n      if (!stat || this._needsNewFile(stat.size)) {\n        // If `stats.size` is greater than the `maxsize` for this\n        // instance then try again.\n        return this._incFile(() => this.stat(callback));\n      }\n\n      // Once we have figured out what the filename is, set it\n      // and return the size.\n      this.filename = target;\n      callback(null, stat.size);\n    });\n  }\n\n  /**\n   * Closes the stream associated with this instance.\n   * @param {function} cb - TODO: add param description.\n   * @returns {undefined}\n   */\n  close(cb) {\n    if (!this._stream) {\n      return;\n    }\n\n    this._stream.end(() => {\n      if (cb) {\n        cb(); // eslint-disable-line callback-return\n      }\n      this.emit('flush');\n      this.emit('closed');\n    });\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {number} size - TODO: add param description.\n   * @returns {undefined}\n   */\n  _needsNewFile(size) {\n    size = size || this._size;\n    return this.maxsize && size >= this.maxsize;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Error} err - TODO: add param description.\n   * @returns {undefined}\n   */\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Stream} stream - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  _setupStream(stream) {\n    stream.on('error', this._onError);\n\n    return stream;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Stream} stream - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  _cleanupStream(stream) {\n    stream.removeListener('error', this._onError);\n    stream.destroy();\n    return stream;\n  }\n\n  /**\n   * TODO: add method description.\n   */\n  _rotateFile() {\n    this._incFile(() => this.open());\n  }\n\n  /**\n   * Unpipe from the stream that has been marked as full and end it so it\n   * flushes to disk.\n   *\n   * @param {function} callback - Callback for when the current file has closed.\n   * @private\n   */\n  _endStream(callback = () => { }) {\n    if (this._dest) {\n      this._stream.unpipe(this._dest);\n      this._dest.end(() => {\n        this._cleanupStream(this._dest);\n        callback();\n      });\n    } else {\n      callback(); // eslint-disable-line callback-return\n    }\n  }\n\n  /**\n   * Returns the WritableStream for the active file on this instance. If we\n   * should gzip the file then a zlib stream is returned.\n   *\n   * @param {ReadableStream} source –PassThrough to pipe to the file when open.\n   * @returns {WritableStream} Stream that writes to disk for the active file.\n   */\n  _createStream(source) {\n    const fullpath = path.join(this.dirname, this.filename);\n\n    debug('create stream start', fullpath, this.options);\n    const dest = fs.createWriteStream(fullpath, this.options)\n      // TODO: What should we do with errors here?\n      .on('error', err => debug(err))\n      .on('close', () => debug('close', dest.path, dest.bytesWritten))\n      .on('open', () => {\n        debug('file open ok', fullpath);\n        this.emit('open', fullpath);\n        source.pipe(dest);\n\n        // If rotation occured during the open operation then we immediately\n        // start writing to a new PassThrough, begin opening the next file\n        // and cleanup the previous source and dest once the source has drained.\n        if (this.rotatedWhileOpening) {\n          this._stream = new PassThrough();\n          this._stream.setMaxListeners(30);\n          this._rotateFile();\n          this.rotatedWhileOpening = false;\n          this._cleanupStream(dest);\n          source.end();\n        }\n      });\n\n    debug('create stream ok', fullpath);\n    return dest;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  _incFile(callback) {\n    debug('_incFile', this.filename);\n    const ext = path.extname(this._basename);\n    const basename = path.basename(this._basename, ext);\n    const tasks = [];\n\n    if (this.zippedArchive) {\n      tasks.push(\n        function (cb) {\n          const num = this._created > 0 && !this.tailable ? this._created : '';\n          this._compressFile(\n            path.join(this.dirname, `${basename}${num}${ext}`),\n            path.join(this.dirname, `${basename}${num}${ext}.gz`),\n            cb\n          );\n        }.bind(this)\n      );\n    }\n\n    tasks.push(\n      function (cb) {\n        if (!this.tailable) {\n          this._created += 1;\n          this._checkMaxFilesIncrementing(ext, basename, cb);\n        } else {\n          this._checkMaxFilesTailable(ext, basename, cb);\n        }\n      }.bind(this)\n    );\n\n    asyncSeries(tasks, callback);\n  }\n\n  /**\n   * Gets the next filename to use for this instance in the case that log\n   * filesizes are being capped.\n   * @returns {string} - TODO: add return description.\n   * @private\n   */\n  _getFile() {\n    const ext = path.extname(this._basename);\n    const basename = path.basename(this._basename, ext);\n    const isRotation = this.rotationFormat\n      ? this.rotationFormat()\n      : this._created;\n\n    // Caveat emptor (indexzero): rotationFormat() was broken by design When\n    // combined with max files because the set of files to unlink is never\n    // stored.\n    return !this.tailable && this._created\n      ? `${basename}${isRotation}${ext}`\n      : `${basename}${ext}`;\n  }\n\n  /**\n   * Increment the number of files created or checked by this instance.\n   * @param {mixed} ext - TODO: add param description.\n   * @param {mixed} basename - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {undefined}\n   * @private\n   */\n  _checkMaxFilesIncrementing(ext, basename, callback) {\n    // Check for maxFiles option and delete file.\n    if (!this.maxFiles || this._created < this.maxFiles) {\n      return setImmediate(callback);\n    }\n\n    const oldest = this._created - this.maxFiles;\n    const isOldest = oldest !== 0 ? oldest : '';\n    const isZipped = this.zippedArchive ? '.gz' : '';\n    const filePath = `${basename}${isOldest}${ext}${isZipped}`;\n    const target = path.join(this.dirname, filePath);\n\n    fs.unlink(target, callback);\n  }\n\n  /**\n   * Roll files forward based on integer, up to maxFiles. e.g. if base if\n   * file.log and it becomes oversized, roll to file1.log, and allow file.log\n   * to be re-used. If file is oversized again, roll file1.log to file2.log,\n   * roll file.log to file1.log, and so on.\n   * @param {mixed} ext - TODO: add param description.\n   * @param {mixed} basename - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {undefined}\n   * @private\n   */\n  _checkMaxFilesTailable(ext, basename, callback) {\n    const tasks = [];\n    if (!this.maxFiles) {\n      return;\n    }\n\n    // const isZipped = this.zippedArchive ? '.gz' : '';\n    const isZipped = this.zippedArchive ? '.gz' : '';\n    for (let x = this.maxFiles - 1; x > 1; x--) {\n      tasks.push(function (i, cb) {\n        let fileName = `${basename}${(i - 1)}${ext}${isZipped}`;\n        const tmppath = path.join(this.dirname, fileName);\n\n        fs.exists(tmppath, exists => {\n          if (!exists) {\n            return cb(null);\n          }\n\n          fileName = `${basename}${i}${ext}${isZipped}`;\n          fs.rename(tmppath, path.join(this.dirname, fileName), cb);\n        });\n      }.bind(this, x));\n    }\n\n    asyncSeries(tasks, () => {\n      fs.rename(\n        path.join(this.dirname, `${basename}${ext}${isZipped}`),\n        path.join(this.dirname, `${basename}1${ext}${isZipped}`),\n        callback\n      );\n    });\n  }\n\n  /**\n   * Compresses src to dest with gzip and unlinks src\n   * @param {string} src - path to source file.\n   * @param {string} dest - path to zipped destination file.\n   * @param {Function} callback - callback called after file has been compressed.\n   * @returns {undefined}\n   * @private\n   */\n  _compressFile(src, dest, callback) {\n    fs.access(src, fs.F_OK, (err) => {\n      if (err) {\n        return callback();\n      }\n      var gzip = zlib.createGzip();\n      var inp = fs.createReadStream(src);\n      var out = fs.createWriteStream(dest);\n      out.on('finish', () => {\n        fs.unlink(src, callback);\n      });\n      inp.pipe(gzip).pipe(out);\n    });\n  }\n\n  _createLogDirIfNotExist(dirPath) {\n    /* eslint-disable no-sync */\n    if (!fs.existsSync(dirPath)) {\n      fs.mkdirSync(dirPath, { recursive: true });\n    }\n    /* eslint-enable no-sync */\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}