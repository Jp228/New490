{"ast":null,"code":"//import './App.css';\n//import './publisher.js'\n\n/*function App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n      </header>\n    </div>\n  );\n}*/\n\n/*import React, { useState } from 'react';\n\nconst App = () => {\n  const [message, setMessage] = useState('');\n  const [status, setStatus] = useState('');\n\n  const handleSendMessage = async () => {\n    try {\n      const connection = new window.AMQP.Connection('amqp://guest:guest@192.168.192.1:5672');\n      const queue = connection.declareQueue('your_queue_name');\n      queue.send(message);\n      setStatus('Message sent successfully!');\n      connection.close();\n    } catch (error) {\n      console.error('Error sending message:', error.message);\n      setStatus('Error sending message');\n    }\n  };\n\n  return (\n    <div>\n      <h1>RabbitMQ Form</h1>\n      <label>\n        Message:\n        <input type=\"text\" value={message} onChange={(e) => setMessage(e.target.value)} />\n      </label>\n      <button onClick={handleSendMessage}>Submit</button>\n      <p>Status: {status}</p>\n      \n      <script src=\"https://cdn.jsdelivr.net/npm/amqp-ts/browser/amqp-ts.min.js\"></script>\n    </div>\n  );\n};\n/*\n//export default RabbitMQForm;\n\nconst amqp = require('amqplib');\n\nconst queue = 'hello';\nconst text = 'Hello World!';\n\n(async () => {\n  let connection;\n  try {\n    connection = await amqp.connect('amqp://192.168.192.1:5672');\n    const channel = await connection.createChannel();\n\n    await channel.assertQueue(queue, { durable: false });\n\n    // NB: `sentToQueue` and `publish` both return a boolean\n    // indicating whether it's OK to send again straight away, or\n    // (when `false`) that you should wait for the event `'drain'`\n    // to fire before writing again. We're just doing the one write,\n    // so we'll ignore it.\n    channel.sendToQueue(queue, Buffer.from(text));\n    console.log(\" [x] Sent '%s'\", text);\n    await channel.close();\n  }\n  catch (err) {\n    console.warn(err);\n  }\n  finally {\n    if (connection) await connection.close();\n  };\n})();  */\n\n//export default App;","map":{"version":3,"names":[],"sources":["/home/jp228/Desktop/frontend/src/App.js"],"sourcesContent":["//import './App.css';\n//import './publisher.js'\n\n\n/*function App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n      </header>\n    </div>\n  );\n}*/\n\n/*import React, { useState } from 'react';\n\nconst App = () => {\n  const [message, setMessage] = useState('');\n  const [status, setStatus] = useState('');\n\n  const handleSendMessage = async () => {\n    try {\n      const connection = new window.AMQP.Connection('amqp://guest:guest@192.168.192.1:5672');\n      const queue = connection.declareQueue('your_queue_name');\n      queue.send(message);\n      setStatus('Message sent successfully!');\n      connection.close();\n    } catch (error) {\n      console.error('Error sending message:', error.message);\n      setStatus('Error sending message');\n    }\n  };\n\n  return (\n    <div>\n      <h1>RabbitMQ Form</h1>\n      <label>\n        Message:\n        <input type=\"text\" value={message} onChange={(e) => setMessage(e.target.value)} />\n      </label>\n      <button onClick={handleSendMessage}>Submit</button>\n      <p>Status: {status}</p>\n      \n      <script src=\"https://cdn.jsdelivr.net/npm/amqp-ts/browser/amqp-ts.min.js\"></script>\n    </div>\n  );\n};\n/*\n//export default RabbitMQForm;\n\nconst amqp = require('amqplib');\n\nconst queue = 'hello';\nconst text = 'Hello World!';\n\n(async () => {\n  let connection;\n  try {\n    connection = await amqp.connect('amqp://192.168.192.1:5672');\n    const channel = await connection.createChannel();\n\n    await channel.assertQueue(queue, { durable: false });\n\n    // NB: `sentToQueue` and `publish` both return a boolean\n    // indicating whether it's OK to send again straight away, or\n    // (when `false`) that you should wait for the event `'drain'`\n    // to fire before writing again. We're just doing the one write,\n    // so we'll ignore it.\n    channel.sendToQueue(queue, Buffer.from(text));\n    console.log(\" [x] Sent '%s'\", text);\n    await channel.close();\n  }\n  catch (err) {\n    console.warn(err);\n  }\n  finally {\n    if (connection) await connection.close();\n  };\n})();  */\n\n\n//export default App;\n"],"mappings":"AAAA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}