{"ast":null,"code":"//\n//\n//\n\n'use strict';\n\n/**\n * A bitset implementation, after that in java.util.  Yes there\n * already exist such things, but none implement next{Clear|Set}Bit or\n * equivalent, and none involved me tooling about for an evening.\n */\nclass BitSet {\n  /**\n   * @param {number} [size]\n   */\n  constructor(size) {\n    if (size) {\n      const numWords = Math.ceil(size / 32);\n      this.words = new Array(numWords);\n    } else {\n      this.words = [];\n    }\n    this.wordsInUse = 0; // = number, not index\n  }\n\n  /**\n   * @param {number} numWords\n   */\n  ensureSize(numWords) {\n    const wordsPresent = this.words.length;\n    if (wordsPresent < numWords) {\n      this.words = this.words.concat(new Array(numWords - wordsPresent));\n    }\n  }\n\n  /**\n   * @param {number} bitIndex\n   */\n  set(bitIndex) {\n    const w = wordIndex(bitIndex);\n    if (w >= this.wordsInUse) {\n      this.ensureSize(w + 1);\n      this.wordsInUse = w + 1;\n    }\n    const bit = 1 << bitIndex;\n    this.words[w] |= bit;\n  }\n\n  /**\n   * @param {number} bitIndex\n   */\n  clear(bitIndex) {\n    const w = wordIndex(bitIndex);\n    if (w >= this.wordsInUse) return;\n    const mask = ~(1 << bitIndex);\n    this.words[w] &= mask;\n  }\n\n  /**\n   * @param {number} bitIndex\n   */\n  get(bitIndex) {\n    const w = wordIndex(bitIndex);\n    if (w >= this.wordsInUse) return false; // >= since index vs size\n    const bit = 1 << bitIndex;\n    return !!(this.words[w] & bit);\n  }\n\n  /**\n   * Give the next bit that is set on or after fromIndex, or -1 if no such bit\n   *\n   * @param {number} fromIndex\n   */\n  nextSetBit(fromIndex) {\n    let w = wordIndex(fromIndex);\n    if (w >= this.wordsInUse) return -1;\n\n    // the right-hand side is shifted to only test the bits of the first\n    // word that are > fromIndex\n    let word = this.words[w] & 0xffffffff << fromIndex;\n    while (true) {\n      if (word) return w * 32 + trailingZeros(word);\n      w++;\n      if (w === this.wordsInUse) return -1;\n      word = this.words[w];\n    }\n  }\n\n  /**\n   * @param {number} fromIndex\n   */\n  nextClearBit(fromIndex) {\n    let w = wordIndex(fromIndex);\n    if (w >= this.wordsInUse) return fromIndex;\n    let word = ~this.words[w] & 0xffffffff << fromIndex;\n    while (true) {\n      if (word) return w * 32 + trailingZeros(word);\n      w++;\n      if (w == this.wordsInUse) return w * 32;\n      word = ~this.words[w];\n    }\n  }\n}\n\n/**\n * @param {number} bitIndex\n */\nfunction wordIndex(bitIndex) {\n  return Math.floor(bitIndex / 32);\n}\n\n/**\n * @param {number} i\n */\nfunction trailingZeros(i) {\n  // From Hacker's Delight, via JDK. Probably far less effective here,\n  // since bit ops are not necessarily the quick way to do things in\n  // JS.\n  if (i === 0) return 32;\n  let y,\n    n = 31;\n  y = i << 16;\n  if (y != 0) {\n    n = n - 16;\n    i = y;\n  }\n  y = i << 8;\n  if (y != 0) {\n    n = n - 8;\n    i = y;\n  }\n  y = i << 4;\n  if (y != 0) {\n    n = n - 4;\n    i = y;\n  }\n  y = i << 2;\n  if (y != 0) {\n    n = n - 2;\n    i = y;\n  }\n  return n - (i << 1 >>> 31);\n}\nmodule.exports.BitSet = BitSet;","map":{"version":3,"names":["BitSet","constructor","size","numWords","Math","ceil","words","Array","wordsInUse","ensureSize","wordsPresent","length","concat","set","bitIndex","w","wordIndex","bit","clear","mask","get","nextSetBit","fromIndex","word","trailingZeros","nextClearBit","floor","i","y","n","module","exports"],"sources":["/home/jp228/Desktop/frontend/node_modules/amqplib/lib/bitset.js"],"sourcesContent":["//\n//\n//\n\n'use strict';\n\n/**\n * A bitset implementation, after that in java.util.  Yes there\n * already exist such things, but none implement next{Clear|Set}Bit or\n * equivalent, and none involved me tooling about for an evening.\n */\nclass BitSet {\n  /**\n   * @param {number} [size]\n   */\n  constructor(size) {\n    if (size) {\n      const numWords = Math.ceil(size / 32);\n      this.words = new Array(numWords);\n    }\n    else {\n      this.words = [];\n    }\n    this.wordsInUse = 0; // = number, not index\n  }\n\n  /**\n   * @param {number} numWords\n   */\n  ensureSize(numWords) {\n    const wordsPresent = this.words.length;\n    if (wordsPresent < numWords) {\n      this.words = this.words.concat(new Array(numWords - wordsPresent));\n    }\n  }\n\n  /**\n   * @param {number} bitIndex\n   */\n  set(bitIndex) {\n    const w = wordIndex(bitIndex);\n    if (w >= this.wordsInUse) {\n      this.ensureSize(w + 1);\n      this.wordsInUse = w + 1;\n    }\n    const bit = 1 << bitIndex;\n    this.words[w] |= bit;\n  }\n\n  /**\n   * @param {number} bitIndex\n   */\n  clear(bitIndex) {\n    const w = wordIndex(bitIndex);\n    if (w >= this.wordsInUse) return;\n    const mask = ~(1 << bitIndex);\n    this.words[w] &= mask;\n  }\n\n  /**\n   * @param {number} bitIndex\n   */\n  get(bitIndex) {\n    const w = wordIndex(bitIndex);\n    if (w >= this.wordsInUse) return false; // >= since index vs size\n    const bit = 1 << bitIndex;\n    return !!(this.words[w] & bit);\n  }\n\n  /**\n   * Give the next bit that is set on or after fromIndex, or -1 if no such bit\n   *\n   * @param {number} fromIndex\n   */\n  nextSetBit(fromIndex) {\n    let w = wordIndex(fromIndex);\n    if (w >= this.wordsInUse) return -1;\n\n    // the right-hand side is shifted to only test the bits of the first\n    // word that are > fromIndex\n    let word = this.words[w] & (0xffffffff << fromIndex);\n    while (true) {\n      if (word) return (w * 32) + trailingZeros(word);\n      w++;\n      if (w === this.wordsInUse) return -1;\n      word = this.words[w];\n    }\n  }\n\n  /**\n   * @param {number} fromIndex\n   */\n  nextClearBit(fromIndex) {\n    let w = wordIndex(fromIndex);\n    if (w >= this.wordsInUse) return fromIndex;\n\n    let word = ~(this.words[w]) & (0xffffffff << fromIndex);\n    while (true) {\n      if (word) return (w * 32) + trailingZeros(word);\n      w++;\n      if (w == this.wordsInUse) return w * 32;\n      word = ~(this.words[w]);\n    }\n  }\n}\n\n/**\n * @param {number} bitIndex\n */\nfunction wordIndex(bitIndex) {\n  return Math.floor(bitIndex / 32);\n}\n\n/**\n * @param {number} i\n */\nfunction trailingZeros(i) {\n  // From Hacker's Delight, via JDK. Probably far less effective here,\n  // since bit ops are not necessarily the quick way to do things in\n  // JS.\n  if (i === 0) return 32;\n  let y, n = 31;\n  y = i << 16; if (y != 0) { n = n -16; i = y; }\n  y = i << 8;  if (y != 0) { n = n - 8; i = y; }\n  y = i << 4;  if (y != 0) { n = n - 4; i = y; }\n  y = i << 2;  if (y != 0) { n = n - 2; i = y; }\n  return n - ((i << 1) >>> 31);\n}\n\nmodule.exports.BitSet = BitSet;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}