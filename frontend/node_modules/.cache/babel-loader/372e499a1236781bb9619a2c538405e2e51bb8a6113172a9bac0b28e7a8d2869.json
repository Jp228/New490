{"ast":null,"code":"import * as crypto from 'crypto';\nimport { EventEmitter } from 'events';\nimport pb from 'promise-breaker';\nimport { promisify } from 'util';\nconst MAX_MESSAGES_PER_BATCH = 1000;\nconst randomBytes = promisify(crypto.randomBytes);\nconst IRRECOVERABLE_ERRORS = [403, 404, 406, 501, 502, 503, 504, 505, 530, 540, 541 // AMQP Internal Error.\n];\n/**\n * Calls to `publish()` or `sendToQueue()` work just like in amqplib, but messages are queued internally and\n * are guaranteed to be delivered.  If the underlying connection drops, ChannelWrapper will wait for a new\n * connection and continue.\n *\n * Events:\n * * `connect` - emitted every time this channel connects or reconnects.\n * * `error(err, {name})` - emitted if an error occurs setting up the channel.\n * * `drop({message, err})` - called when a JSON message was dropped because it could not be encoded.\n * * `close` - emitted when this channel closes via a call to `close()`\n *\n */\nexport default class ChannelWrapper extends EventEmitter {\n  addListener(event, listener) {\n    return super.addListener(event, listener);\n  }\n  on(event, listener) {\n    return super.on(event, listener);\n  }\n  once(event, listener) {\n    return super.once(event, listener);\n  }\n  prependListener(event, listener) {\n    return super.prependListener(event, listener);\n  }\n  prependOnceListener(event, listener) {\n    return super.prependOnceListener(event, listener);\n  }\n  /**\n   *  Adds a new 'setup handler'.\n   *\n   * `setup(channel, [cb])` is a function to call when a new underlying channel is created - handy for asserting\n   * exchanges and queues exists, and whatnot.  The `channel` object here is a ConfigChannel from amqplib.\n   * The `setup` function should return a Promise (or optionally take a callback) - no messages will be sent until\n   * this Promise resolves.\n   *\n   * If there is a connection, `setup()` will be run immediately, and the addSetup Promise/callback won't resolve\n   * until `setup` is complete.  Note that in this case, if the setup throws an error, no 'error' event will\n   * be emitted, since you can just handle the error here (although the `setup` will still be added for future\n   * reconnects, even if it throws an error.)\n   *\n   * Setup functions should, ideally, not throw errors, but if they do then the ChannelWrapper will emit an 'error'\n   * event.\n   *\n   * @param setup - setup function.\n   * @param [done] - callback.\n   * @returns - Resolves when complete.\n   */\n  addSetup(setup, done) {\n    return pb.addCallback(done, (this._settingUp || Promise.resolve()).then(() => {\n      this._setups.push(setup);\n      if (this._channel) {\n        return pb.call(setup, this, this._channel);\n      } else {\n        return undefined;\n      }\n    }));\n  }\n  /**\n   * Remove a setup function added with `addSetup`.  If there is currently a\n   * connection, `teardown(channel, [cb])` will be run immediately, and the\n   * returned Promise will not resolve until it completes.\n   *\n   * @param {function} setup - the setup function to remove.\n   * @param {function} [teardown] - `function(channel, [cb])` to run to tear\n   *   down the channel.\n   * @param {function} [done] - Optional callback.\n   * @returns {void | Promise} - Resolves when complete.\n   */\n  removeSetup(setup, teardown, done) {\n    return pb.addCallback(done, () => {\n      this._setups = this._setups.filter(s => s !== setup);\n      return (this._settingUp || Promise.resolve()).then(() => this._channel && teardown ? pb.call(teardown, this, this._channel) : undefined);\n    });\n  }\n  /**\n   * Returns a Promise which resolves when this channel next connects.\n   * (Mainly here for unit testing...)\n   *\n   * @param [done] - Optional callback.\n   * @returns - Resolves when connected.\n   */\n  waitForConnect(done) {\n    return pb.addCallback(done, this._channel && !this._settingUp ? Promise.resolve() : new Promise(resolve => this.once('connect', resolve)));\n  }\n  /*\n   * Publish a message to the channel.\n   *\n   * This works just like amqplib's `publish()`, except if the channel is not\n   * connected, this will wait until the channel is connected.  Returns a\n   * Promise which will only resolve when the message has been succesfully sent.\n   * The returned promise will be rejected if `close()` is called on this\n   * channel before it can be sent, if `options.json` is set and the message\n   * can't be encoded, or if the broker rejects the message for some reason.\n   *\n   */\n  publish(exchange, routingKey, content, options, done) {\n    return pb.addCallback(done, new Promise((resolve, reject) => {\n      const {\n        timeout,\n        ...opts\n      } = options || {};\n      this._enqueueMessage({\n        type: 'publish',\n        exchange,\n        routingKey,\n        content: this._getEncodedMessage(content),\n        resolve,\n        reject,\n        options: opts,\n        isTimedout: false\n      }, timeout || this._publishTimeout);\n      this._startWorker();\n    }));\n  }\n  /*\n   * Send a message to a queue.\n   *\n   * This works just like amqplib's `sendToQueue`, except if the channel is not connected, this will wait until the\n   * channel is connected.  Returns a Promise which will only resolve when the message has been succesfully sent.\n   * The returned promise will be rejected only if `close()` is called on this channel before it can be sent.\n   *\n   * `message` here should be a JSON-able object.\n   */\n  sendToQueue(queue, content, options, done) {\n    const encodedContent = this._getEncodedMessage(content);\n    return pb.addCallback(done, new Promise((resolve, reject) => {\n      const {\n        timeout,\n        ...opts\n      } = options || {};\n      this._enqueueMessage({\n        type: 'sendToQueue',\n        queue,\n        content: encodedContent,\n        resolve,\n        reject,\n        options: opts,\n        isTimedout: false\n      }, timeout || this._publishTimeout);\n      this._startWorker();\n    }));\n  }\n  _enqueueMessage(message, timeout) {\n    if (timeout) {\n      message.timeout = setTimeout(() => {\n        let idx = this._messages.indexOf(message);\n        if (idx !== -1) {\n          this._messages.splice(idx, 1);\n        } else {\n          idx = this._unconfirmedMessages.indexOf(message);\n          if (idx !== -1) {\n            this._unconfirmedMessages.splice(idx, 1);\n          }\n        }\n        message.isTimedout = true;\n        message.reject(new Error('timeout'));\n      }, timeout);\n    }\n    this._messages.push(message);\n  }\n  /**\n   * Create a new ChannelWrapper.\n   *\n   * @param connectionManager - connection manager which\n   *   created this channel.\n   * @param [options] -\n   * @param [options.name] - A name for this channel.  Handy for debugging.\n   * @param [options.setup] - A default setup function to call.  See\n   *   `addSetup` for details.\n   * @param [options.json] - if true, then ChannelWrapper assumes all\n   *   messages passed to `publish()` and `sendToQueue()` are plain JSON objects.\n   *   These will be encoded automatically before being sent.\n   *\n   */\n  constructor(connectionManager, options = {}) {\n    var _a, _b;\n    super();\n    /** If we're in the process of creating a channel, this is a Promise which\n     * will resolve when the channel is set up.  Otherwise, this is `null`.\n     */\n    this._settingUp = undefined;\n    /** Queued messages, not yet sent. */\n    this._messages = [];\n    /** Oublished, but not yet confirmed messages. */\n    this._unconfirmedMessages = [];\n    /** Consumers which will be reconnected on channel errors etc. */\n    this._consumers = [];\n    /**\n     * True to create a ConfirmChannel. False to create a regular Channel.\n     */\n    this._confirm = true;\n    /**\n     * True if the \"worker\" is busy sending messages.  False if we need to\n     * start the worker to get stuff done.\n     */\n    this._working = false;\n    /**\n     *  We kill off workers when we disconnect.  Whenever we start a new\n     * worker, we bump up the `_workerNumber` - this makes it so if stale\n     * workers ever do wake up, they'll know to stop working.\n     */\n    this._workerNumber = 0;\n    /**\n     * True if the underlying channel has room for more messages.\n     */\n    this._channelHasRoom = true;\n    this._onConnect = this._onConnect.bind(this);\n    this._onDisconnect = this._onDisconnect.bind(this);\n    this._connectionManager = connectionManager;\n    this._confirm = (_a = options.confirm) !== null && _a !== void 0 ? _a : true;\n    this.name = options.name;\n    this._publishTimeout = options.publishTimeout;\n    this._json = (_b = options.json) !== null && _b !== void 0 ? _b : false;\n    // Array of setup functions to call.\n    this._setups = [];\n    this._consumers = [];\n    if (options.setup) {\n      this._setups.push(options.setup);\n    }\n    const connection = connectionManager.connection;\n    if (connection) {\n      this._onConnect({\n        connection\n      });\n    }\n    connectionManager.on('connect', this._onConnect);\n    connectionManager.on('disconnect', this._onDisconnect);\n  }\n  // Called whenever we connect to the broker.\n  async _onConnect({\n    connection\n  }) {\n    this._irrecoverableCode = undefined;\n    try {\n      let channel;\n      if (this._confirm) {\n        channel = await connection.createConfirmChannel();\n      } else {\n        channel = await connection.createChannel();\n      }\n      this._channel = channel;\n      this._channelHasRoom = true;\n      channel.on('close', () => this._onChannelClose(channel));\n      channel.on('drain', () => this._onChannelDrain());\n      this._settingUp = Promise.all(this._setups.map(setupFn =>\n      // TODO: Use a timeout here to guard against setupFns that never resolve?\n      pb.call(setupFn, this, channel).catch(err => {\n        if (err.name === 'IllegalOperationError') {\n          // Don't emit an error if setups failed because the channel closed.\n          return;\n        }\n        this.emit('error', err, {\n          name: this.name\n        });\n      }))).then(() => {\n        return Promise.all(this._consumers.map(c => this._reconnectConsumer(c)));\n      }).then(() => {\n        this._settingUp = undefined;\n      });\n      await this._settingUp;\n      if (!this._channel) {\n        // Can happen if channel closes while we're setting up.\n        return;\n      }\n      // Since we just connected, publish any queued messages\n      this._startWorker();\n      this.emit('connect');\n    } catch (err) {\n      this.emit('error', err, {\n        name: this.name\n      });\n      this._settingUp = undefined;\n      this._channel = undefined;\n    }\n  }\n  // Called whenever the channel closes.\n  _onChannelClose(channel) {\n    if (this._channel === channel) {\n      this._channel = undefined;\n    }\n    // Wait for another reconnect to create a new channel.\n  }\n  /** Called whenever the channel drains. */\n  _onChannelDrain() {\n    this._channelHasRoom = true;\n    this._startWorker();\n  }\n  // Called whenever we disconnect from the AMQP server.\n  _onDisconnect(ex) {\n    this._irrecoverableCode = ex.err instanceof Error ? ex.err.code : undefined;\n    this._channel = undefined;\n    this._settingUp = undefined;\n    // Kill off the current worker.  We never get any kind of error for messages in flight - see\n    // https://github.com/squaremo/amqp.node/issues/191.\n    this._working = false;\n  }\n  // Returns the number of unsent messages queued on this channel.\n  queueLength() {\n    return this._messages.length;\n  }\n  // Destroy this channel.\n  //\n  // Any unsent messages will have their associated Promises rejected.\n  //\n  close() {\n    return Promise.resolve().then(() => {\n      this._working = false;\n      if (this._messages.length !== 0) {\n        // Reject any unsent messages.\n        this._messages.forEach(message => {\n          if (message.timeout) {\n            clearTimeout(message.timeout);\n          }\n          message.reject(new Error('Channel closed'));\n        });\n      }\n      if (this._unconfirmedMessages.length !== 0) {\n        // Reject any unconfirmed messages.\n        this._unconfirmedMessages.forEach(message => {\n          if (message.timeout) {\n            clearTimeout(message.timeout);\n          }\n          message.reject(new Error('Channel closed'));\n        });\n      }\n      this._connectionManager.removeListener('connect', this._onConnect);\n      this._connectionManager.removeListener('disconnect', this._onDisconnect);\n      const answer = this._channel && this._channel.close() || undefined;\n      this._channel = undefined;\n      this.emit('close');\n      return answer;\n    });\n  }\n  _shouldPublish() {\n    return this._messages.length > 0 && !this._settingUp && !!this._channel && this._channelHasRoom;\n  }\n  // Start publishing queued messages, if there isn't already a worker doing this.\n  _startWorker() {\n    if (!this._working && this._shouldPublish()) {\n      this._working = true;\n      this._workerNumber++;\n      this._publishQueuedMessages(this._workerNumber);\n    }\n  }\n  // Define if a message can cause irrecoverable error\n  _canWaitReconnection() {\n    return !this._irrecoverableCode || !IRRECOVERABLE_ERRORS.includes(this._irrecoverableCode);\n  }\n  _messageResolved(message, result) {\n    removeUnconfirmedMessage(this._unconfirmedMessages, message);\n    message.resolve(result);\n  }\n  _messageRejected(message, err) {\n    if (!this._channel && this._canWaitReconnection()) {\n      // Tried to write to a closed channel.  Leave the message in the queue and we'll try again when\n      // we reconnect.\n      removeUnconfirmedMessage(this._unconfirmedMessages, message);\n      this._messages.push(message);\n    } else {\n      // Something went wrong trying to send this message - could be JSON.stringify failed, could be\n      // the broker rejected the message. Either way, reject it back\n      removeUnconfirmedMessage(this._unconfirmedMessages, message);\n      message.reject(err);\n    }\n  }\n  _getEncodedMessage(content) {\n    let encodedMessage;\n    if (this._json) {\n      encodedMessage = Buffer.from(JSON.stringify(content));\n    } else if (typeof content === 'string') {\n      encodedMessage = Buffer.from(content);\n    } else if (content instanceof Buffer) {\n      encodedMessage = content;\n    } else if (typeof content === 'object' && typeof content.toString === 'function') {\n      encodedMessage = Buffer.from(content.toString());\n    } else {\n      console.warn('amqp-connection-manager: Sending JSON message, but json option not speicifed');\n      encodedMessage = Buffer.from(JSON.stringify(content));\n    }\n    return encodedMessage;\n  }\n  _publishQueuedMessages(workerNumber) {\n    const channel = this._channel;\n    if (!channel || !this._shouldPublish() || !this._working || workerNumber !== this._workerNumber) {\n      // Can't publish anything right now...\n      this._working = false;\n      return;\n    }\n    try {\n      // Send messages in batches of 1000 - don't want to starve the event loop.\n      let sendsLeft = MAX_MESSAGES_PER_BATCH;\n      while (this._channelHasRoom && this._messages.length > 0 && sendsLeft > 0) {\n        sendsLeft--;\n        const message = this._messages.shift();\n        if (!message) {\n          break;\n        }\n        let thisCanSend = true;\n        switch (message.type) {\n          case 'publish':\n            {\n              if (this._confirm) {\n                this._unconfirmedMessages.push(message);\n                thisCanSend = this._channelHasRoom = channel.publish(message.exchange, message.routingKey, message.content, message.options, err => {\n                  if (message.isTimedout) {\n                    return;\n                  }\n                  if (message.timeout) {\n                    clearTimeout(message.timeout);\n                  }\n                  if (err) {\n                    this._messageRejected(message, err);\n                  } else {\n                    this._messageResolved(message, thisCanSend);\n                  }\n                });\n              } else {\n                if (message.timeout) {\n                  clearTimeout(message.timeout);\n                }\n                thisCanSend = this._channelHasRoom = channel.publish(message.exchange, message.routingKey, message.content, message.options);\n                message.resolve(thisCanSend);\n              }\n              break;\n            }\n          case 'sendToQueue':\n            {\n              if (this._confirm) {\n                this._unconfirmedMessages.push(message);\n                thisCanSend = this._channelHasRoom = channel.sendToQueue(message.queue, message.content, message.options, err => {\n                  if (message.isTimedout) {\n                    return;\n                  }\n                  if (message.timeout) {\n                    clearTimeout(message.timeout);\n                  }\n                  if (err) {\n                    this._messageRejected(message, err);\n                  } else {\n                    this._messageResolved(message, thisCanSend);\n                  }\n                });\n              } else {\n                if (message.timeout) {\n                  clearTimeout(message.timeout);\n                }\n                thisCanSend = this._channelHasRoom = channel.sendToQueue(message.queue, message.content, message.options);\n                message.resolve(thisCanSend);\n              }\n              break;\n            }\n          /* istanbul ignore next */\n          default:\n            throw new Error(`Unhandled message type ${message.type}`);\n        }\n      }\n      // If we didn't send all the messages, send some more...\n      if (this._channelHasRoom && this._messages.length > 0) {\n        setImmediate(() => this._publishQueuedMessages(workerNumber));\n      } else {\n        this._working = false;\n      }\n      /* istanbul ignore next */\n    } catch (err) {\n      this._working = false;\n      this.emit('error', err);\n    }\n  }\n  /**\n   * Setup a consumer\n   * This consumer will be reconnected on cancellation and channel errors.\n   */\n  async consume(queue, onMessage, options = {}) {\n    const consumerTag = options.consumerTag || (await randomBytes(16)).toString('hex');\n    const consumer = {\n      consumerTag: null,\n      queue,\n      onMessage,\n      options: {\n        ...options,\n        consumerTag\n      }\n    };\n    if (this._settingUp) {\n      await this._settingUp;\n    }\n    this._consumers.push(consumer);\n    await this._consume(consumer);\n    return {\n      consumerTag\n    };\n  }\n  async _consume(consumer) {\n    if (!this._channel) {\n      return;\n    }\n    const {\n      prefetch,\n      ...options\n    } = consumer.options;\n    if (typeof prefetch === 'number') {\n      this._channel.prefetch(prefetch, false);\n    }\n    const {\n      consumerTag\n    } = await this._channel.consume(consumer.queue, msg => {\n      if (!msg) {\n        consumer.consumerTag = null;\n        this._reconnectConsumer(consumer).catch(err => {\n          if (err.code === 404) {\n            // Ignore errors caused by queue not declared. In\n            // those cases the connection will reconnect and\n            // then consumers reestablished. The full reconnect\n            // might be avoided if we assert the queue again\n            // before starting to consume.\n            return;\n          }\n          this.emit('error', err);\n        });\n        return;\n      }\n      consumer.onMessage(msg);\n    }, options);\n    consumer.consumerTag = consumerTag;\n  }\n  async _reconnectConsumer(consumer) {\n    if (!this._consumers.includes(consumer)) {\n      // Intentionally canceled\n      return;\n    }\n    await this._consume(consumer);\n  }\n  /**\n   * Cancel all consumers\n   */\n  async cancelAll() {\n    const consumers = this._consumers;\n    this._consumers = [];\n    if (!this._channel) {\n      return;\n    }\n    const channel = this._channel;\n    await Promise.all(consumers.reduce((acc, consumer) => {\n      if (consumer.consumerTag) {\n        acc.push(channel.cancel(consumer.consumerTag));\n      }\n      return acc;\n    }, []));\n  }\n  async cancel(consumerTag) {\n    const idx = this._consumers.findIndex(x => x.options.consumerTag === consumerTag);\n    if (idx === -1) {\n      return;\n    }\n    const consumer = this._consumers[idx];\n    this._consumers.splice(idx, 1);\n    if (this._channel && consumer.consumerTag) {\n      await this._channel.cancel(consumer.consumerTag);\n    }\n  }\n  /** Send an `ack` to the underlying channel. */\n  ack(message, allUpTo) {\n    this._channel && this._channel.ack(message, allUpTo);\n  }\n  /** Send an `ackAll` to the underlying channel. */\n  ackAll() {\n    this._channel && this._channel.ackAll();\n  }\n  /** Send a `nack` to the underlying channel. */\n  nack(message, allUpTo, requeue) {\n    this._channel && this._channel.nack(message, allUpTo, requeue);\n  }\n  /** Send a `nackAll` to the underlying channel. */\n  nackAll(requeue) {\n    this._channel && this._channel.nackAll(requeue);\n  }\n  /** Send a `purgeQueue` to the underlying channel. */\n  async purgeQueue(queue) {\n    if (this._channel) {\n      return await this._channel.purgeQueue(queue);\n    } else {\n      throw new Error(`Not connected.`);\n    }\n  }\n  /** Send a `checkQueue` to the underlying channel. */\n  async checkQueue(queue) {\n    if (this._channel) {\n      return await this._channel.checkQueue(queue);\n    } else {\n      throw new Error(`Not connected.`);\n    }\n  }\n  /** Send a `assertQueue` to the underlying channel. */\n  async assertQueue(queue, options) {\n    if (this._channel) {\n      return await this._channel.assertQueue(queue, options);\n    } else {\n      return {\n        queue,\n        messageCount: 0,\n        consumerCount: 0\n      };\n    }\n  }\n  /** Send a `bindQueue` to the underlying channel. */\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  async bindQueue(queue, source, pattern, args) {\n    if (this._channel) {\n      await this._channel.bindQueue(queue, source, pattern, args);\n    }\n  }\n  /** Send a `unbindQueue` to the underlying channel. */\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  async unbindQueue(queue, source, pattern, args) {\n    if (this._channel) {\n      await this._channel.unbindQueue(queue, source, pattern, args);\n    }\n  }\n  /** Send a `deleteQueue` to the underlying channel. */\n  async deleteQueue(queue, options) {\n    if (this._channel) {\n      return await this._channel.deleteQueue(queue, options);\n    } else {\n      throw new Error(`Not connected.`);\n    }\n  }\n  /** Send a `assertExchange` to the underlying channel. */\n  async assertExchange(exchange, type, options) {\n    if (this._channel) {\n      return await this._channel.assertExchange(exchange, type, options);\n    } else {\n      return {\n        exchange\n      };\n    }\n  }\n  /** Send a `bindExchange` to the underlying channel. */\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  async bindExchange(destination, source, pattern, args) {\n    if (this._channel) {\n      return await this._channel.bindExchange(destination, source, pattern, args);\n    } else {\n      throw new Error(`Not connected.`);\n    }\n  }\n  /** Send a `checkExchange` to the underlying channel. */\n  async checkExchange(exchange) {\n    if (this._channel) {\n      return await this._channel.checkExchange(exchange);\n    } else {\n      throw new Error(`Not connected.`);\n    }\n  }\n  /** Send a `deleteExchange` to the underlying channel. */\n  async deleteExchange(exchange, options) {\n    if (this._channel) {\n      return await this._channel.deleteExchange(exchange, options);\n    } else {\n      throw new Error(`Not connected.`);\n    }\n  }\n  /** Send a `unbindExchange` to the underlying channel. */\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  async unbindExchange(destination, source, pattern, args) {\n    if (this._channel) {\n      return await this._channel.unbindExchange(destination, source, pattern, args);\n    } else {\n      throw new Error(`Not connected.`);\n    }\n  }\n  /** Send a `get` to the underlying channel. */\n  async get(queue, options) {\n    if (this._channel) {\n      return await this._channel.get(queue, options);\n    } else {\n      throw new Error(`Not connected.`);\n    }\n  }\n}\nfunction removeUnconfirmedMessage(arr, message) {\n  const toRemove = arr.indexOf(message);\n  if (toRemove === -1) {\n    throw new Error(`Message is not in _unconfirmedMessages!`);\n  }\n  const removed = arr.splice(toRemove, 1);\n  return removed[0];\n}","map":{"version":3,"names":["crypto","EventEmitter","pb","promisify","MAX_MESSAGES_PER_BATCH","randomBytes","IRRECOVERABLE_ERRORS","ChannelWrapper","addListener","event","listener","on","once","prependListener","prependOnceListener","addSetup","setup","done","addCallback","_settingUp","Promise","resolve","then","_setups","push","_channel","call","undefined","removeSetup","teardown","filter","s","waitForConnect","publish","exchange","routingKey","content","options","reject","timeout","opts","_enqueueMessage","type","_getEncodedMessage","isTimedout","_publishTimeout","_startWorker","sendToQueue","queue","encodedContent","message","setTimeout","idx","_messages","indexOf","splice","_unconfirmedMessages","Error","constructor","connectionManager","_consumers","_confirm","_working","_workerNumber","_channelHasRoom","_onConnect","bind","_onDisconnect","_connectionManager","_a","confirm","name","publishTimeout","_json","_b","json","connection","_irrecoverableCode","channel","createConfirmChannel","createChannel","_onChannelClose","_onChannelDrain","all","map","setupFn","catch","err","emit","c","_reconnectConsumer","ex","code","queueLength","length","close","forEach","clearTimeout","removeListener","answer","_shouldPublish","_publishQueuedMessages","_canWaitReconnection","includes","_messageResolved","result","removeUnconfirmedMessage","_messageRejected","encodedMessage","Buffer","from","JSON","stringify","toString","console","warn","workerNumber","sendsLeft","shift","thisCanSend","setImmediate","consume","onMessage","consumerTag","consumer","_consume","prefetch","msg","cancelAll","consumers","reduce","acc","cancel","findIndex","x","ack","allUpTo","ackAll","nack","requeue","nackAll","purgeQueue","checkQueue","assertQueue","messageCount","consumerCount","bindQueue","source","pattern","args","unbindQueue","deleteQueue","assertExchange","bindExchange","destination","checkExchange","deleteExchange","unbindExchange","get","arr","toRemove","removed"],"sources":["../../src/ChannelWrapper.ts"],"sourcesContent":[null],"mappings":"AAEA,OAAO,KAAKA,MAAM,MAAM,QAAQ;AAChC,SAASC,YAAY,QAAQ,QAAQ;AACrC,OAAOC,EAAE,MAAM,iBAAiB;AAChC,SAASC,SAAS,QAAQ,MAAM;AAGhC,MAAMC,sBAAsB,GAAG,IAAI;AAEnC,MAAMC,WAAW,GAAGF,SAAS,CAACH,MAAM,CAACK,WAAW,CAAC;AA0EjD,MAAMC,oBAAoB,GAAG,CACzB,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,CAAE;AAAA,CACR;AAED;;;;;;;;;;;;AAYA,eAAc,MAAOC,cAAe,SAAQN,YAAY;EA0DpDO,WAAWA,CAACC,KAAa,EAAEC,QAAkC;IACzD,OAAO,KAAK,CAACF,WAAW,CAACC,KAAK,EAAEC,QAAQ,CAAC;EAC7C;EAMAC,EAAEA,CAACF,KAAa,EAAEC,QAAkC;IAChD,OAAO,KAAK,CAACC,EAAE,CAACF,KAAK,EAAEC,QAAQ,CAAC;EACpC;EAMAE,IAAIA,CAACH,KAAa,EAAEC,QAAkC;IAClD,OAAO,KAAK,CAACE,IAAI,CAACH,KAAK,EAAEC,QAAQ,CAAC;EACtC;EAMAG,eAAeA,CAACJ,KAAa,EAAEC,QAAkC;IAC7D,OAAO,KAAK,CAACG,eAAe,CAACJ,KAAK,EAAEC,QAAQ,CAAC;EACjD;EASAI,mBAAmBA,CAACL,KAAa,EAAEC,QAAkC;IACjE,OAAO,KAAK,CAACI,mBAAmB,CAACL,KAAK,EAAEC,QAAQ,CAAC;EACrD;EAEA;;;;;;;;;;;;;;;;;;;;EAoBAK,QAAQA,CAACC,KAAgB,EAAEC,IAAwB;IAC/C,OAAOf,EAAE,CAACgB,WAAW,CACjBD,IAAI,EACJ,CAAC,IAAI,CAACE,UAAU,IAAIC,OAAO,CAACC,OAAO,EAAE,EAAEC,IAAI,CAAC,MAAK;MAC7C,IAAI,CAACC,OAAO,CAACC,IAAI,CAACR,KAAK,CAAC;MACxB,IAAI,IAAI,CAACS,QAAQ,EAAE;QACf,OAAOvB,EAAE,CAACwB,IAAI,CAACV,KAAK,EAAE,IAAI,EAAE,IAAI,CAACS,QAAQ,CAAC;OAC7C,MAAM;QACH,OAAOE,SAAS;;IAExB,CAAC,CAAC,CACL;EACL;EAEA;;;;;;;;;;;EAWAC,WAAWA,CAACZ,KAAgB,EAAEa,QAAoB,EAAEZ,IAAwB;IACxE,OAAOf,EAAE,CAACgB,WAAW,CAACD,IAAI,EAAE,MAAK;MAC7B,IAAI,CAACM,OAAO,GAAG,IAAI,CAACA,OAAO,CAACO,MAAM,CAAEC,CAAC,IAAKA,CAAC,KAAKf,KAAK,CAAC;MAEtD,OAAO,CAAC,IAAI,CAACG,UAAU,IAAIC,OAAO,CAACC,OAAO,EAAE,EAAEC,IAAI,CAAC,MAC/C,IAAI,CAACG,QAAQ,IAAII,QAAQ,GAAG3B,EAAE,CAACwB,IAAI,CAACG,QAAQ,EAAE,IAAI,EAAE,IAAI,CAACJ,QAAQ,CAAC,GAAGE,SAAS,CACjF;IACL,CAAC,CAAC;EACN;EAEA;;;;;;;EAOAK,cAAcA,CAACf,IAAwB;IACnC,OAAOf,EAAE,CAACgB,WAAW,CACjBD,IAAI,EACJ,IAAI,CAACQ,QAAQ,IAAI,CAAC,IAAI,CAACN,UAAU,GAC3BC,OAAO,CAACC,OAAO,EAAE,GACjB,IAAID,OAAO,CAAEC,OAAO,IAAK,IAAI,CAACT,IAAI,CAAC,SAAS,EAAES,OAAO,CAAC,CAAC,CAChE;EACL;EAEA;;;;;;;;;;;EAWAY,OAAOA,CACHC,QAAgB,EAChBC,UAAkB,EAClBC,OAAkC,EAClCC,OAAwB,EACxBpB,IAA2B;IAE3B,OAAOf,EAAE,CAACgB,WAAW,CACjBD,IAAI,EACJ,IAAIG,OAAO,CAAU,CAACC,OAAO,EAAEiB,MAAM,KAAI;MACrC,MAAM;QAAEC,OAAO;QAAE,GAAGC;MAAI,CAAE,GAAGH,OAAO,IAAI,EAAE;MAC1C,IAAI,CAACI,eAAe,CAChB;QACIC,IAAI,EAAE,SAAS;QACfR,QAAQ;QACRC,UAAU;QACVC,OAAO,EAAE,IAAI,CAACO,kBAAkB,CAACP,OAAO,CAAC;QACzCf,OAAO;QACPiB,MAAM;QACND,OAAO,EAAEG,IAAI;QACbI,UAAU,EAAE;OACf,EACDL,OAAO,IAAI,IAAI,CAACM,eAAe,CAClC;MACD,IAAI,CAACC,YAAY,EAAE;IACvB,CAAC,CAAC,CACL;EACL;EAEA;;;;;;;;;EASAC,WAAWA,CACPC,KAAa,EACbZ,OAAkC,EAClCC,OAAwB,EACxBpB,IAA2B;IAE3B,MAAMgC,cAAc,GAAG,IAAI,CAACN,kBAAkB,CAACP,OAAO,CAAC;IAEvD,OAAOlC,EAAE,CAACgB,WAAW,CACjBD,IAAI,EACJ,IAAIG,OAAO,CAAU,CAACC,OAAO,EAAEiB,MAAM,KAAI;MACrC,MAAM;QAAEC,OAAO;QAAE,GAAGC;MAAI,CAAE,GAAGH,OAAO,IAAI,EAAE;MAC1C,IAAI,CAACI,eAAe,CAChB;QACIC,IAAI,EAAE,aAAa;QACnBM,KAAK;QACLZ,OAAO,EAAEa,cAAc;QACvB5B,OAAO;QACPiB,MAAM;QACND,OAAO,EAAEG,IAAI;QACbI,UAAU,EAAE;OACf,EACDL,OAAO,IAAI,IAAI,CAACM,eAAe,CAClC;MACD,IAAI,CAACC,YAAY,EAAE;IACvB,CAAC,CAAC,CACL;EACL;EAEQL,eAAeA,CAACS,OAAgB,EAAEX,OAAgB;IACtD,IAAIA,OAAO,EAAE;MACTW,OAAO,CAACX,OAAO,GAAGY,UAAU,CAAC,MAAK;QAC9B,IAAIC,GAAG,GAAG,IAAI,CAACC,SAAS,CAACC,OAAO,CAACJ,OAAO,CAAC;QACzC,IAAIE,GAAG,KAAK,CAAC,CAAC,EAAE;UACZ,IAAI,CAACC,SAAS,CAACE,MAAM,CAACH,GAAG,EAAE,CAAC,CAAC;SAChC,MAAM;UACHA,GAAG,GAAG,IAAI,CAACI,oBAAoB,CAACF,OAAO,CAACJ,OAAO,CAAC;UAChD,IAAIE,GAAG,KAAK,CAAC,CAAC,EAAE;YACZ,IAAI,CAACI,oBAAoB,CAACD,MAAM,CAACH,GAAG,EAAE,CAAC,CAAC;;;QAGhDF,OAAO,CAACN,UAAU,GAAG,IAAI;QACzBM,OAAO,CAACZ,MAAM,CAAC,IAAImB,KAAK,CAAC,SAAS,CAAC,CAAC;MACxC,CAAC,EAAElB,OAAO,CAAC;;IAEf,IAAI,CAACc,SAAS,CAAC7B,IAAI,CAAC0B,OAAO,CAAC;EAChC;EAEA;;;;;;;;;;;;;;EAcAQ,YAAYC,iBAAyC,EAAEtB,OAAA,GAA6B,EAAE;;IAClF,KAAK,EAAE;IApRX;;;IAGQ,KAAAlB,UAAU,GAA8BQ,SAAS;IAEzD;IACQ,KAAA0B,SAAS,GAAc,EAAE;IACjC;IACQ,KAAAG,oBAAoB,GAAc,EAAE;IAG5C;IACQ,KAAAI,UAAU,GAAe,EAAE;IASnC;;;IAGQ,KAAAC,QAAQ,GAAG,IAAI;IACvB;;;;IAIQ,KAAAC,QAAQ,GAAG,KAAK;IAExB;;;;;IAKQ,KAAAC,aAAa,GAAG,CAAC;IAEzB;;;IAGQ,KAAAC,eAAe,GAAG,IAAI;IA4O1B,IAAI,CAACC,UAAU,GAAG,IAAI,CAACA,UAAU,CAACC,IAAI,CAAC,IAAI,CAAC;IAC5C,IAAI,CAACC,aAAa,GAAG,IAAI,CAACA,aAAa,CAACD,IAAI,CAAC,IAAI,CAAC;IAClD,IAAI,CAACE,kBAAkB,GAAGT,iBAAiB;IAC3C,IAAI,CAACE,QAAQ,GAAG,CAAAQ,EAAA,GAAAhC,OAAO,CAACiC,OAAO,cAAAD,EAAA,cAAAA,EAAA,GAAI,IAAI;IACvC,IAAI,CAACE,IAAI,GAAGlC,OAAO,CAACkC,IAAI;IAExB,IAAI,CAAC1B,eAAe,GAAGR,OAAO,CAACmC,cAAc;IAC7C,IAAI,CAACC,KAAK,GAAG,CAAAC,EAAA,GAAArC,OAAO,CAACsC,IAAI,cAAAD,EAAA,cAAAA,EAAA,GAAI,KAAK;IAElC;IACA,IAAI,CAACnD,OAAO,GAAG,EAAE;IACjB,IAAI,CAACqC,UAAU,GAAG,EAAE;IAEpB,IAAIvB,OAAO,CAACrB,KAAK,EAAE;MACf,IAAI,CAACO,OAAO,CAACC,IAAI,CAACa,OAAO,CAACrB,KAAK,CAAC;;IAGpC,MAAM4D,UAAU,GAAGjB,iBAAiB,CAACiB,UAAU;IAC/C,IAAIA,UAAU,EAAE;MACZ,IAAI,CAACX,UAAU,CAAC;QAAEW;MAAU,CAAE,CAAC;;IAEnCjB,iBAAiB,CAAChD,EAAE,CAAC,SAAS,EAAE,IAAI,CAACsD,UAAU,CAAC;IAChDN,iBAAiB,CAAChD,EAAE,CAAC,YAAY,EAAE,IAAI,CAACwD,aAAa,CAAC;EAC1D;EAEA;EACQ,MAAMF,UAAUA,CAAC;IAAEW;EAAU,CAAsC;IACvE,IAAI,CAACC,kBAAkB,GAAGlD,SAAS;IAEnC,IAAI;MACA,IAAImD,OAAgB;MACpB,IAAI,IAAI,CAACjB,QAAQ,EAAE;QACfiB,OAAO,GAAG,MAAMF,UAAU,CAACG,oBAAoB,EAAE;OACpD,MAAM;QACHD,OAAO,GAAG,MAAMF,UAAU,CAACI,aAAa,EAAE;;MAG9C,IAAI,CAACvD,QAAQ,GAAGqD,OAAO;MACvB,IAAI,CAACd,eAAe,GAAG,IAAI;MAC3Bc,OAAO,CAACnE,EAAE,CAAC,OAAO,EAAE,MAAM,IAAI,CAACsE,eAAe,CAACH,OAAO,CAAC,CAAC;MACxDA,OAAO,CAACnE,EAAE,CAAC,OAAO,EAAE,MAAM,IAAI,CAACuE,eAAe,EAAE,CAAC;MAEjD,IAAI,CAAC/D,UAAU,GAAGC,OAAO,CAAC+D,GAAG,CACzB,IAAI,CAAC5D,OAAO,CAAC6D,GAAG,CAAEC,OAAO;MACrB;MACAnF,EAAE,CAACwB,IAAI,CAAC2D,OAAO,EAAE,IAAI,EAAEP,OAAO,CAAC,CAACQ,KAAK,CAAEC,GAAG,IAAI;QAC1C,IAAIA,GAAG,CAAChB,IAAI,KAAK,uBAAuB,EAAE;UACtC;UACA;;QAEJ,IAAI,CAACiB,IAAI,CAAC,OAAO,EAAED,GAAG,EAAE;UAAEhB,IAAI,EAAE,IAAI,CAACA;QAAI,CAAE,CAAC;MAChD,CAAC,CAAC,CACL,CACJ,CACIjD,IAAI,CAAC,MAAK;QACP,OAAOF,OAAO,CAAC+D,GAAG,CAAC,IAAI,CAACvB,UAAU,CAACwB,GAAG,CAAEK,CAAC,IAAK,IAAI,CAACC,kBAAkB,CAACD,CAAC,CAAC,CAAC,CAAC;MAC9E,CAAC,CAAC,CACDnE,IAAI,CAAC,MAAK;QACP,IAAI,CAACH,UAAU,GAAGQ,SAAS;MAC/B,CAAC,CAAC;MACN,MAAM,IAAI,CAACR,UAAU;MAErB,IAAI,CAAC,IAAI,CAACM,QAAQ,EAAE;QAChB;QACA;;MAGJ;MACA,IAAI,CAACqB,YAAY,EAAE;MACnB,IAAI,CAAC0C,IAAI,CAAC,SAAS,CAAC;KACvB,CAAC,OAAOD,GAAG,EAAE;MACV,IAAI,CAACC,IAAI,CAAC,OAAO,EAAED,GAAG,EAAE;QAAEhB,IAAI,EAAE,IAAI,CAACA;MAAI,CAAE,CAAC;MAC5C,IAAI,CAACpD,UAAU,GAAGQ,SAAS;MAC3B,IAAI,CAACF,QAAQ,GAAGE,SAAS;;EAEjC;EAEA;EACQsD,eAAeA,CAACH,OAAgB;IACpC,IAAI,IAAI,CAACrD,QAAQ,KAAKqD,OAAO,EAAE;MAC3B,IAAI,CAACrD,QAAQ,GAAGE,SAAS;;IAE7B;EACJ;EAEA;EACQuD,eAAeA,CAAA;IACnB,IAAI,CAAClB,eAAe,GAAG,IAAI;IAC3B,IAAI,CAAClB,YAAY,EAAE;EACvB;EAEA;EACQqB,aAAaA,CAACwB,EAAqC;IACvD,IAAI,CAACd,kBAAkB,GAAGc,EAAE,CAACJ,GAAG,YAAY9B,KAAK,GAAGkC,EAAE,CAACJ,GAAG,CAACK,IAAI,GAAGjE,SAAS;IAC3E,IAAI,CAACF,QAAQ,GAAGE,SAAS;IACzB,IAAI,CAACR,UAAU,GAAGQ,SAAS;IAE3B;IACA;IACA,IAAI,CAACmC,QAAQ,GAAG,KAAK;EACzB;EAEA;EACA+B,WAAWA,CAAA;IACP,OAAO,IAAI,CAACxC,SAAS,CAACyC,MAAM;EAChC;EAEA;EACA;EACA;EACA;EACAC,KAAKA,CAAA;IACD,OAAO3E,OAAO,CAACC,OAAO,EAAE,CAACC,IAAI,CAAC,MAAK;MAC/B,IAAI,CAACwC,QAAQ,GAAG,KAAK;MACrB,IAAI,IAAI,CAACT,SAAS,CAACyC,MAAM,KAAK,CAAC,EAAE;QAC7B;QACA,IAAI,CAACzC,SAAS,CAAC2C,OAAO,CAAE9C,OAAO,IAAI;UAC/B,IAAIA,OAAO,CAACX,OAAO,EAAE;YACjB0D,YAAY,CAAC/C,OAAO,CAACX,OAAO,CAAC;;UAEjCW,OAAO,CAACZ,MAAM,CAAC,IAAImB,KAAK,CAAC,gBAAgB,CAAC,CAAC;QAC/C,CAAC,CAAC;;MAEN,IAAI,IAAI,CAACD,oBAAoB,CAACsC,MAAM,KAAK,CAAC,EAAE;QACxC;QACA,IAAI,CAACtC,oBAAoB,CAACwC,OAAO,CAAE9C,OAAO,IAAI;UAC1C,IAAIA,OAAO,CAACX,OAAO,EAAE;YACjB0D,YAAY,CAAC/C,OAAO,CAACX,OAAO,CAAC;;UAEjCW,OAAO,CAACZ,MAAM,CAAC,IAAImB,KAAK,CAAC,gBAAgB,CAAC,CAAC;QAC/C,CAAC,CAAC;;MAGN,IAAI,CAACW,kBAAkB,CAAC8B,cAAc,CAAC,SAAS,EAAE,IAAI,CAACjC,UAAU,CAAC;MAClE,IAAI,CAACG,kBAAkB,CAAC8B,cAAc,CAAC,YAAY,EAAE,IAAI,CAAC/B,aAAa,CAAC;MACxE,MAAMgC,MAAM,GAAI,IAAI,CAAC1E,QAAQ,IAAI,IAAI,CAACA,QAAQ,CAACsE,KAAK,EAAE,IAAKpE,SAAS;MACpE,IAAI,CAACF,QAAQ,GAAGE,SAAS;MAEzB,IAAI,CAAC6D,IAAI,CAAC,OAAO,CAAC;MAElB,OAAOW,MAAM;IACjB,CAAC,CAAC;EACN;EAEQC,cAAcA,CAAA;IAClB,OACI,IAAI,CAAC/C,SAAS,CAACyC,MAAM,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC3E,UAAU,IAAI,CAAC,CAAC,IAAI,CAACM,QAAQ,IAAI,IAAI,CAACuC,eAAe;EAEhG;EAEA;EACQlB,YAAYA,CAAA;IAChB,IAAI,CAAC,IAAI,CAACgB,QAAQ,IAAI,IAAI,CAACsC,cAAc,EAAE,EAAE;MACzC,IAAI,CAACtC,QAAQ,GAAG,IAAI;MACpB,IAAI,CAACC,aAAa,EAAE;MACpB,IAAI,CAACsC,sBAAsB,CAAC,IAAI,CAACtC,aAAa,CAAC;;EAEvD;EAEA;EACQuC,oBAAoBA,CAAA;IACxB,OAAO,CAAC,IAAI,CAACzB,kBAAkB,IAAI,CAACvE,oBAAoB,CAACiG,QAAQ,CAAC,IAAI,CAAC1B,kBAAkB,CAAC;EAC9F;EAEQ2B,gBAAgBA,CAACtD,OAAgB,EAAEuD,MAAe;IACtDC,wBAAwB,CAAC,IAAI,CAAClD,oBAAoB,EAAEN,OAAO,CAAC;IAC5DA,OAAO,CAAC7B,OAAO,CAACoF,MAAM,CAAC;EAC3B;EAEQE,gBAAgBA,CAACzD,OAAgB,EAAEqC,GAAU;IACjD,IAAI,CAAC,IAAI,CAAC9D,QAAQ,IAAI,IAAI,CAAC6E,oBAAoB,EAAE,EAAE;MAC/C;MACA;MACAI,wBAAwB,CAAC,IAAI,CAAClD,oBAAoB,EAAEN,OAAO,CAAC;MAC5D,IAAI,CAACG,SAAS,CAAC7B,IAAI,CAAC0B,OAAO,CAAC;KAC/B,MAAM;MACH;MACA;MACAwD,wBAAwB,CAAC,IAAI,CAAClD,oBAAoB,EAAEN,OAAO,CAAC;MAC5DA,OAAO,CAACZ,MAAM,CAACiD,GAAG,CAAC;;EAE3B;EAEQ5C,kBAAkBA,CAACP,OAAkC;IACzD,IAAIwE,cAAsB;IAE1B,IAAI,IAAI,CAACnC,KAAK,EAAE;MACZmC,cAAc,GAAGC,MAAM,CAACC,IAAI,CAACC,IAAI,CAACC,SAAS,CAAC5E,OAAO,CAAC,CAAC;KACxD,MAAM,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MACpCwE,cAAc,GAAGC,MAAM,CAACC,IAAI,CAAC1E,OAAO,CAAC;KACxC,MAAM,IAAIA,OAAO,YAAYyE,MAAM,EAAE;MAClCD,cAAc,GAAGxE,OAAO;KAC3B,MAAM,IAAI,OAAOA,OAAO,KAAK,QAAQ,IAAI,OAAQA,OAAe,CAAC6E,QAAQ,KAAK,UAAU,EAAE;MACvFL,cAAc,GAAGC,MAAM,CAACC,IAAI,CAAE1E,OAAe,CAAC6E,QAAQ,EAAE,CAAC;KAC5D,MAAM;MACHC,OAAO,CAACC,IAAI,CACR,8EAA8E,CACjF;MACDP,cAAc,GAAGC,MAAM,CAACC,IAAI,CAACC,IAAI,CAACC,SAAS,CAAC5E,OAAO,CAAC,CAAC;;IAGzD,OAAOwE,cAAc;EACzB;EAEQP,sBAAsBA,CAACe,YAAoB;IAC/C,MAAMtC,OAAO,GAAG,IAAI,CAACrD,QAAQ;IAC7B,IACI,CAACqD,OAAO,IACR,CAAC,IAAI,CAACsB,cAAc,EAAE,IACtB,CAAC,IAAI,CAACtC,QAAQ,IACdsD,YAAY,KAAK,IAAI,CAACrD,aAAa,EACrC;MACE;MACA,IAAI,CAACD,QAAQ,GAAG,KAAK;MACrB;;IAGJ,IAAI;MACA;MACA,IAAIuD,SAAS,GAAGjH,sBAAsB;MACtC,OAAO,IAAI,CAAC4D,eAAe,IAAI,IAAI,CAACX,SAAS,CAACyC,MAAM,GAAG,CAAC,IAAIuB,SAAS,GAAG,CAAC,EAAE;QACvEA,SAAS,EAAE;QAEX,MAAMnE,OAAO,GAAG,IAAI,CAACG,SAAS,CAACiE,KAAK,EAAE;QACtC,IAAI,CAACpE,OAAO,EAAE;UACV;;QAGJ,IAAIqE,WAAW,GAAG,IAAI;QAEtB,QAAQrE,OAAO,CAACR,IAAI;UAChB,KAAK,SAAS;YAAE;cACZ,IAAI,IAAI,CAACmB,QAAQ,EAAE;gBACf,IAAI,CAACL,oBAAoB,CAAChC,IAAI,CAAC0B,OAAO,CAAC;gBACvCqE,WAAW,GAAG,IAAI,CAACvD,eAAe,GAAGc,OAAO,CAAC7C,OAAO,CAChDiB,OAAO,CAAChB,QAAQ,EAChBgB,OAAO,CAACf,UAAU,EAClBe,OAAO,CAACd,OAAO,EACfc,OAAO,CAACb,OAAO,EACdkD,GAAG,IAAI;kBACJ,IAAIrC,OAAO,CAACN,UAAU,EAAE;oBACpB;;kBAGJ,IAAIM,OAAO,CAACX,OAAO,EAAE;oBACjB0D,YAAY,CAAC/C,OAAO,CAACX,OAAO,CAAC;;kBAGjC,IAAIgD,GAAG,EAAE;oBACL,IAAI,CAACoB,gBAAgB,CAACzD,OAAO,EAAEqC,GAAG,CAAC;mBACtC,MAAM;oBACH,IAAI,CAACiB,gBAAgB,CAACtD,OAAO,EAAEqE,WAAW,CAAC;;gBAEnD,CAAC,CACJ;eACJ,MAAM;gBACH,IAAIrE,OAAO,CAACX,OAAO,EAAE;kBACjB0D,YAAY,CAAC/C,OAAO,CAACX,OAAO,CAAC;;gBAEjCgF,WAAW,GAAG,IAAI,CAACvD,eAAe,GAAGc,OAAO,CAAC7C,OAAO,CAChDiB,OAAO,CAAChB,QAAQ,EAChBgB,OAAO,CAACf,UAAU,EAClBe,OAAO,CAACd,OAAO,EACfc,OAAO,CAACb,OAAO,CAClB;gBACDa,OAAO,CAAC7B,OAAO,CAACkG,WAAW,CAAC;;cAEhC;;UAEJ,KAAK,aAAa;YAAE;cAChB,IAAI,IAAI,CAAC1D,QAAQ,EAAE;gBACf,IAAI,CAACL,oBAAoB,CAAChC,IAAI,CAAC0B,OAAO,CAAC;gBACvCqE,WAAW,GAAG,IAAI,CAACvD,eAAe,GAAGc,OAAO,CAAC/B,WAAW,CACpDG,OAAO,CAACF,KAAK,EACbE,OAAO,CAACd,OAAO,EACfc,OAAO,CAACb,OAAO,EACdkD,GAAG,IAAI;kBACJ,IAAIrC,OAAO,CAACN,UAAU,EAAE;oBACpB;;kBAGJ,IAAIM,OAAO,CAACX,OAAO,EAAE;oBACjB0D,YAAY,CAAC/C,OAAO,CAACX,OAAO,CAAC;;kBAGjC,IAAIgD,GAAG,EAAE;oBACL,IAAI,CAACoB,gBAAgB,CAACzD,OAAO,EAAEqC,GAAG,CAAC;mBACtC,MAAM;oBACH,IAAI,CAACiB,gBAAgB,CAACtD,OAAO,EAAEqE,WAAW,CAAC;;gBAEnD,CAAC,CACJ;eACJ,MAAM;gBACH,IAAIrE,OAAO,CAACX,OAAO,EAAE;kBACjB0D,YAAY,CAAC/C,OAAO,CAACX,OAAO,CAAC;;gBAEjCgF,WAAW,GAAG,IAAI,CAACvD,eAAe,GAAGc,OAAO,CAAC/B,WAAW,CACpDG,OAAO,CAACF,KAAK,EACbE,OAAO,CAACd,OAAO,EACfc,OAAO,CAACb,OAAO,CAClB;gBACDa,OAAO,CAAC7B,OAAO,CAACkG,WAAW,CAAC;;cAEhC;;UAEJ;UACA;YACI,MAAM,IAAI9D,KAAK,CAAC,0BAA2BP,OAAe,CAACR,IAAI,EAAE,CAAC;;;MAI9E;MACA,IAAI,IAAI,CAACsB,eAAe,IAAI,IAAI,CAACX,SAAS,CAACyC,MAAM,GAAG,CAAC,EAAE;QACnD0B,YAAY,CAAC,MAAM,IAAI,CAACnB,sBAAsB,CAACe,YAAY,CAAC,CAAC;OAChE,MAAM;QACH,IAAI,CAACtD,QAAQ,GAAG,KAAK;;MAGzB;KACH,CAAC,OAAOyB,GAAG,EAAE;MACV,IAAI,CAACzB,QAAQ,GAAG,KAAK;MACrB,IAAI,CAAC0B,IAAI,CAAC,OAAO,EAAED,GAAG,CAAC;;EAE/B;EAEA;;;;EAIA,MAAMkC,OAAOA,CACTzE,KAAa,EACb0E,SAAgC,EAChCrF,OAAA,GAA2B,EAAE;IAE7B,MAAMsF,WAAW,GAAGtF,OAAO,CAACsF,WAAW,IAAI,CAAC,MAAMtH,WAAW,CAAC,EAAE,CAAC,EAAE4G,QAAQ,CAAC,KAAK,CAAC;IAClF,MAAMW,QAAQ,GAAa;MACvBD,WAAW,EAAE,IAAI;MACjB3E,KAAK;MACL0E,SAAS;MACTrF,OAAO,EAAE;QACL,GAAGA,OAAO;QACVsF;;KAEP;IAED,IAAI,IAAI,CAACxG,UAAU,EAAE;MACjB,MAAM,IAAI,CAACA,UAAU;;IAGzB,IAAI,CAACyC,UAAU,CAACpC,IAAI,CAACoG,QAAQ,CAAC;IAC9B,MAAM,IAAI,CAACC,QAAQ,CAACD,QAAQ,CAAC;IAC7B,OAAO;MAAED;IAAW,CAAE;EAC1B;EAEQ,MAAME,QAAQA,CAACD,QAAkB;IACrC,IAAI,CAAC,IAAI,CAACnG,QAAQ,EAAE;MAChB;;IAGJ,MAAM;MAAEqG,QAAQ;MAAE,GAAGzF;IAAO,CAAE,GAAGuF,QAAQ,CAACvF,OAAO;IACjD,IAAI,OAAOyF,QAAQ,KAAK,QAAQ,EAAE;MAC9B,IAAI,CAACrG,QAAQ,CAACqG,QAAQ,CAACA,QAAQ,EAAE,KAAK,CAAC;;IAG3C,MAAM;MAAEH;IAAW,CAAE,GAAG,MAAM,IAAI,CAAClG,QAAQ,CAACgG,OAAO,CAC/CG,QAAQ,CAAC5E,KAAK,EACb+E,GAAG,IAAI;MACJ,IAAI,CAACA,GAAG,EAAE;QACNH,QAAQ,CAACD,WAAW,GAAG,IAAI;QAC3B,IAAI,CAACjC,kBAAkB,CAACkC,QAAQ,CAAC,CAACtC,KAAK,CAAEC,GAAG,IAAI;UAC5C,IAAIA,GAAG,CAACK,IAAI,KAAK,GAAG,EAAE;YAClB;YACA;YACA;YACA;YACA;YACA;;UAEJ,IAAI,CAACJ,IAAI,CAAC,OAAO,EAAED,GAAG,CAAC;QAC3B,CAAC,CAAC;QACF;;MAEJqC,QAAQ,CAACF,SAAS,CAACK,GAAG,CAAC;IAC3B,CAAC,EACD1F,OAAO,CACV;IACDuF,QAAQ,CAACD,WAAW,GAAGA,WAAW;EACtC;EAEQ,MAAMjC,kBAAkBA,CAACkC,QAAkB;IAC/C,IAAI,CAAC,IAAI,CAAChE,UAAU,CAAC2C,QAAQ,CAACqB,QAAQ,CAAC,EAAE;MACrC;MACA;;IAEJ,MAAM,IAAI,CAACC,QAAQ,CAACD,QAAQ,CAAC;EACjC;EAEA;;;EAGA,MAAMI,SAASA,CAAA;IACX,MAAMC,SAAS,GAAG,IAAI,CAACrE,UAAU;IACjC,IAAI,CAACA,UAAU,GAAG,EAAE;IACpB,IAAI,CAAC,IAAI,CAACnC,QAAQ,EAAE;MAChB;;IAGJ,MAAMqD,OAAO,GAAG,IAAI,CAACrD,QAAQ;IAC7B,MAAML,OAAO,CAAC+D,GAAG,CACb8C,SAAS,CAACC,MAAM,CAAQ,CAACC,GAAG,EAAEP,QAAQ,KAAI;MACtC,IAAIA,QAAQ,CAACD,WAAW,EAAE;QACtBQ,GAAG,CAAC3G,IAAI,CAACsD,OAAO,CAACsD,MAAM,CAACR,QAAQ,CAACD,WAAW,CAAC,CAAC;;MAElD,OAAOQ,GAAG;IACd,CAAC,EAAE,EAAE,CAAC,CACT;EACL;EAEA,MAAMC,MAAMA,CAACT,WAAmB;IAC5B,MAAMvE,GAAG,GAAG,IAAI,CAACQ,UAAU,CAACyE,SAAS,CAAEC,CAAC,IAAKA,CAAC,CAACjG,OAAO,CAACsF,WAAW,KAAKA,WAAW,CAAC;IACnF,IAAIvE,GAAG,KAAK,CAAC,CAAC,EAAE;MACZ;;IAGJ,MAAMwE,QAAQ,GAAG,IAAI,CAAChE,UAAU,CAACR,GAAG,CAAC;IACrC,IAAI,CAACQ,UAAU,CAACL,MAAM,CAACH,GAAG,EAAE,CAAC,CAAC;IAC9B,IAAI,IAAI,CAAC3B,QAAQ,IAAImG,QAAQ,CAACD,WAAW,EAAE;MACvC,MAAM,IAAI,CAAClG,QAAQ,CAAC2G,MAAM,CAACR,QAAQ,CAACD,WAAW,CAAC;;EAExD;EAEA;EACAY,GAAGA,CAACrF,OAAwB,EAAEsF,OAAiB;IAC3C,IAAI,CAAC/G,QAAQ,IAAI,IAAI,CAACA,QAAQ,CAAC8G,GAAG,CAACrF,OAAO,EAAEsF,OAAO,CAAC;EACxD;EAEA;EACAC,MAAMA,CAAA;IACF,IAAI,CAAChH,QAAQ,IAAI,IAAI,CAACA,QAAQ,CAACgH,MAAM,EAAE;EAC3C;EAEA;EACAC,IAAIA,CAACxF,OAAwB,EAAEsF,OAAiB,EAAEG,OAAiB;IAC/D,IAAI,CAAClH,QAAQ,IAAI,IAAI,CAACA,QAAQ,CAACiH,IAAI,CAACxF,OAAO,EAAEsF,OAAO,EAAEG,OAAO,CAAC;EAClE;EAEA;EACAC,OAAOA,CAACD,OAAiB;IACrB,IAAI,CAAClH,QAAQ,IAAI,IAAI,CAACA,QAAQ,CAACmH,OAAO,CAACD,OAAO,CAAC;EACnD;EAEA;EACA,MAAME,UAAUA,CAAC7F,KAAa;IAC1B,IAAI,IAAI,CAACvB,QAAQ,EAAE;MACf,OAAO,MAAM,IAAI,CAACA,QAAQ,CAACoH,UAAU,CAAC7F,KAAK,CAAC;KAC/C,MAAM;MACH,MAAM,IAAIS,KAAK,CAAC,gBAAgB,CAAC;;EAEzC;EAEA;EACA,MAAMqF,UAAUA,CAAC9F,KAAa;IAC1B,IAAI,IAAI,CAACvB,QAAQ,EAAE;MACf,OAAO,MAAM,IAAI,CAACA,QAAQ,CAACqH,UAAU,CAAC9F,KAAK,CAAC;KAC/C,MAAM;MACH,MAAM,IAAIS,KAAK,CAAC,gBAAgB,CAAC;;EAEzC;EAEA;EACA,MAAMsF,WAAWA,CACb/F,KAAa,EACbX,OAAqC;IAErC,IAAI,IAAI,CAACZ,QAAQ,EAAE;MACf,OAAO,MAAM,IAAI,CAACA,QAAQ,CAACsH,WAAW,CAAC/F,KAAK,EAAEX,OAAO,CAAC;KACzD,MAAM;MACH,OAAO;QAAEW,KAAK;QAAEgG,YAAY,EAAE,CAAC;QAAEC,aAAa,EAAE;MAAC,CAAE;;EAE3D;EAEA;EACA;EACA,MAAMC,SAASA,CAAClG,KAAa,EAAEmG,MAAc,EAAEC,OAAe,EAAEC,IAAU;IACtE,IAAI,IAAI,CAAC5H,QAAQ,EAAE;MACf,MAAM,IAAI,CAACA,QAAQ,CAACyH,SAAS,CAAClG,KAAK,EAAEmG,MAAM,EAAEC,OAAO,EAAEC,IAAI,CAAC;;EAEnE;EAEA;EACA;EACA,MAAMC,WAAWA,CAACtG,KAAa,EAAEmG,MAAc,EAAEC,OAAe,EAAEC,IAAU;IACxE,IAAI,IAAI,CAAC5H,QAAQ,EAAE;MACf,MAAM,IAAI,CAACA,QAAQ,CAAC6H,WAAW,CAACtG,KAAK,EAAEmG,MAAM,EAAEC,OAAO,EAAEC,IAAI,CAAC;;EAErE;EAEA;EACA,MAAME,WAAWA,CACbvG,KAAa,EACbX,OAA6B;IAE7B,IAAI,IAAI,CAACZ,QAAQ,EAAE;MACf,OAAO,MAAM,IAAI,CAACA,QAAQ,CAAC8H,WAAW,CAACvG,KAAK,EAAEX,OAAO,CAAC;KACzD,MAAM;MACH,MAAM,IAAIoB,KAAK,CAAC,gBAAgB,CAAC;;EAEzC;EAEA;EACA,MAAM+F,cAAcA,CAChBtH,QAAgB,EAChBQ,IAAkE,EAClEL,OAAgC;IAEhC,IAAI,IAAI,CAACZ,QAAQ,EAAE;MACf,OAAO,MAAM,IAAI,CAACA,QAAQ,CAAC+H,cAAc,CAACtH,QAAQ,EAAEQ,IAAI,EAAEL,OAAO,CAAC;KACrE,MAAM;MACH,OAAO;QAAEH;MAAQ,CAAE;;EAE3B;EAEA;EACA;EACA,MAAMuH,YAAYA,CACdC,WAAmB,EACnBP,MAAc,EACdC,OAAe,EACfC,IAAU;IAEV,IAAI,IAAI,CAAC5H,QAAQ,EAAE;MACf,OAAO,MAAM,IAAI,CAACA,QAAQ,CAACgI,YAAY,CAACC,WAAW,EAAEP,MAAM,EAAEC,OAAO,EAAEC,IAAI,CAAC;KAC9E,MAAM;MACH,MAAM,IAAI5F,KAAK,CAAC,gBAAgB,CAAC;;EAEzC;EAEA;EACA,MAAMkG,aAAaA,CAACzH,QAAgB;IAChC,IAAI,IAAI,CAACT,QAAQ,EAAE;MACf,OAAO,MAAM,IAAI,CAACA,QAAQ,CAACkI,aAAa,CAACzH,QAAQ,CAAC;KACrD,MAAM;MACH,MAAM,IAAIuB,KAAK,CAAC,gBAAgB,CAAC;;EAEzC;EAEA;EACA,MAAMmG,cAAcA,CAChB1H,QAAgB,EAChBG,OAAgC;IAEhC,IAAI,IAAI,CAACZ,QAAQ,EAAE;MACf,OAAO,MAAM,IAAI,CAACA,QAAQ,CAACmI,cAAc,CAAC1H,QAAQ,EAAEG,OAAO,CAAC;KAC/D,MAAM;MACH,MAAM,IAAIoB,KAAK,CAAC,gBAAgB,CAAC;;EAEzC;EAEA;EACA;EACA,MAAMoG,cAAcA,CAChBH,WAAmB,EACnBP,MAAc,EACdC,OAAe,EACfC,IAAU;IAEV,IAAI,IAAI,CAAC5H,QAAQ,EAAE;MACf,OAAO,MAAM,IAAI,CAACA,QAAQ,CAACoI,cAAc,CAACH,WAAW,EAAEP,MAAM,EAAEC,OAAO,EAAEC,IAAI,CAAC;KAChF,MAAM;MACH,MAAM,IAAI5F,KAAK,CAAC,gBAAgB,CAAC;;EAEzC;EAEA;EACA,MAAMqG,GAAGA,CAAC9G,KAAa,EAAEX,OAAqB;IAC1C,IAAI,IAAI,CAACZ,QAAQ,EAAE;MACf,OAAO,MAAM,IAAI,CAACA,QAAQ,CAACqI,GAAG,CAAC9G,KAAK,EAAEX,OAAO,CAAC;KACjD,MAAM;MACH,MAAM,IAAIoB,KAAK,CAAC,gBAAgB,CAAC;;EAEzC;;AAGJ,SAASiD,wBAAwBA,CAACqD,GAAc,EAAE7G,OAAgB;EAC9D,MAAM8G,QAAQ,GAAGD,GAAG,CAACzG,OAAO,CAACJ,OAAO,CAAC;EACrC,IAAI8G,QAAQ,KAAK,CAAC,CAAC,EAAE;IACjB,MAAM,IAAIvG,KAAK,CAAC,yCAAyC,CAAC;;EAE9D,MAAMwG,OAAO,GAAGF,GAAG,CAACxG,MAAM,CAACyG,QAAQ,EAAE,CAAC,CAAC;EACvC,OAAOC,OAAO,CAAC,CAAC,CAAC;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}