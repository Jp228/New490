{"ast":null,"code":"//import './App.css';\n//import './publisher.js'\n\n/*function App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n      </header>\n    </div>\n  );\n}*/\n\n/*import React, { useState } from 'react';\n\nconst App = () => {\n  const [message, setMessage] = useState('');\n  const [status, setStatus] = useState('');\n\n  const handleSendMessage = async () => {\n    try {\n      const connection = new window.AMQP.Connection('amqp://guest:guest@192.168.192.1:5672');\n      const queue = connection.declareQueue('your_queue_name');\n      queue.send(message);\n      setStatus('Message sent successfully!');\n      connection.close();\n    } catch (error) {\n      console.error('Error sending message:', error.message);\n      setStatus('Error sending message');\n    }\n  };\n\n  return (\n    <div>\n      <h1>RabbitMQ Form</h1>\n      <label>\n        Message:\n        <input type=\"text\" value={message} onChange={(e) => setMessage(e.target.value)} />\n      </label>\n      <button onClick={handleSendMessage}>Submit</button>\n      <p>Status: {status}</p>\n      //{ Include the amqp-ts library directly in your HTML file }\n      <script src=\"https://cdn.jsdelivr.net/npm/amqp-ts/browser/amqp-ts.min.js\"></script>\n    </div>\n  );\n};\n\n//export default RabbitMQForm;\n\nconst amqp = require('amqplib');\n\nconst queue = 'hello';\nconst text = 'Hello World!';\n\n(async () => {\n  let connection;\n  try {\n    connection = await amqp.connect('amqp://192.168.192.1:5672');\n    const channel = await connection.createChannel();\n\n    await channel.assertQueue(queue, { durable: false });\n\n    // NB: `sentToQueue` and `publish` both return a boolean\n    // indicating whether it's OK to send again straight away, or\n    // (when `false`) that you should wait for the event `'drain'`\n    // to fire before writing again. We're just doing the one write,\n    // so we'll ignore it.\n    channel.sendToQueue(queue, Buffer.from(text));\n    console.log(\" [x] Sent '%s'\", text);\n    await channel.close();\n  }\n  catch (err) {\n    console.warn(err);\n  }\n  finally {\n    if (connection) await connection.close();\n  };\n})();  */\nvar amqp = require('amqplib/callback_api');\namqp.connect('amqp://localhost', function (error0, connection) {});\namqp.connect('amqp://localhost', function (error0, connection) {\n  if (error0) {\n    throw error0;\n  }\n  connection.createChannel(function (error1, channel) {});\n});\namqp.connect('amqp://localhost', function (error0, connection) {\n  if (error0) {\n    throw error0;\n  }\n  connection.createChannel(function (error1, channel) {\n    if (error1) {\n      throw error1;\n    }\n    var queue = 'hello';\n    var msg = 'Hello world';\n    channel.assertQueue(queue, {\n      durable: false\n    });\n    channel.sendToQueue(queue, Buffer.from(msg));\n    console.log(\" [x] Sent %s\", msg);\n  });\n});\nsetTimeout(function () {\n  connection.close();\n  process.exit(0);\n}, 500);\nexport default App;","map":{"version":3,"names":["amqp","require","connect","error0","connection","createChannel","error1","channel","queue","msg","assertQueue","durable","sendToQueue","Buffer","from","console","log","setTimeout","close","process","exit","App"],"sources":["/home/jp228/Desktop/frontend/src/App.js"],"sourcesContent":["//import './App.css';\n//import './publisher.js'\n\n\n/*function App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n      </header>\n    </div>\n  );\n}*/\n\n/*import React, { useState } from 'react';\n\nconst App = () => {\n  const [message, setMessage] = useState('');\n  const [status, setStatus] = useState('');\n\n  const handleSendMessage = async () => {\n    try {\n      const connection = new window.AMQP.Connection('amqp://guest:guest@192.168.192.1:5672');\n      const queue = connection.declareQueue('your_queue_name');\n      queue.send(message);\n      setStatus('Message sent successfully!');\n      connection.close();\n    } catch (error) {\n      console.error('Error sending message:', error.message);\n      setStatus('Error sending message');\n    }\n  };\n\n  return (\n    <div>\n      <h1>RabbitMQ Form</h1>\n      <label>\n        Message:\n        <input type=\"text\" value={message} onChange={(e) => setMessage(e.target.value)} />\n      </label>\n      <button onClick={handleSendMessage}>Submit</button>\n      <p>Status: {status}</p>\n      //{ Include the amqp-ts library directly in your HTML file }\n      <script src=\"https://cdn.jsdelivr.net/npm/amqp-ts/browser/amqp-ts.min.js\"></script>\n    </div>\n  );\n};\n\n//export default RabbitMQForm;\n\nconst amqp = require('amqplib');\n\nconst queue = 'hello';\nconst text = 'Hello World!';\n\n(async () => {\n  let connection;\n  try {\n    connection = await amqp.connect('amqp://192.168.192.1:5672');\n    const channel = await connection.createChannel();\n\n    await channel.assertQueue(queue, { durable: false });\n\n    // NB: `sentToQueue` and `publish` both return a boolean\n    // indicating whether it's OK to send again straight away, or\n    // (when `false`) that you should wait for the event `'drain'`\n    // to fire before writing again. We're just doing the one write,\n    // so we'll ignore it.\n    channel.sendToQueue(queue, Buffer.from(text));\n    console.log(\" [x] Sent '%s'\", text);\n    await channel.close();\n  }\n  catch (err) {\n    console.warn(err);\n  }\n  finally {\n    if (connection) await connection.close();\n  };\n})();  */\nvar amqp = require('amqplib/callback_api');\namqp.connect('amqp://localhost', function(error0, connection) {});\n\namqp.connect('amqp://localhost', function(error0, connection) {\n  if (error0) {\n    throw error0;\n  }\n  connection.createChannel(function(error1, channel) {});\n});\n\namqp.connect('amqp://localhost', function(error0, connection) {\n  if (error0) {\n    throw error0;\n  }\n  connection.createChannel(function(error1, channel) {\n    if (error1) {\n      throw error1;\n    }\n    var queue = 'hello';\n    var msg = 'Hello world';\n\n    channel.assertQueue(queue, {\n      durable: false\n    });\n\n    channel.sendToQueue(queue, Buffer.from(msg));\n    console.log(\" [x] Sent %s\", msg);\n  });\n});\n\nsetTimeout(function() {\n  connection.close();\n  process.exit(0)\n  }, 500);\n\nexport default App;\n"],"mappings":"AAAA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,IAAI,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AAC1CD,IAAI,CAACE,OAAO,CAAC,kBAAkB,EAAE,UAASC,MAAM,EAAEC,UAAU,EAAE,CAAC,CAAC,CAAC;AAEjEJ,IAAI,CAACE,OAAO,CAAC,kBAAkB,EAAE,UAASC,MAAM,EAAEC,UAAU,EAAE;EAC5D,IAAID,MAAM,EAAE;IACV,MAAMA,MAAM;EACd;EACAC,UAAU,CAACC,aAAa,CAAC,UAASC,MAAM,EAAEC,OAAO,EAAE,CAAC,CAAC,CAAC;AACxD,CAAC,CAAC;AAEFP,IAAI,CAACE,OAAO,CAAC,kBAAkB,EAAE,UAASC,MAAM,EAAEC,UAAU,EAAE;EAC5D,IAAID,MAAM,EAAE;IACV,MAAMA,MAAM;EACd;EACAC,UAAU,CAACC,aAAa,CAAC,UAASC,MAAM,EAAEC,OAAO,EAAE;IACjD,IAAID,MAAM,EAAE;MACV,MAAMA,MAAM;IACd;IACA,IAAIE,KAAK,GAAG,OAAO;IACnB,IAAIC,GAAG,GAAG,aAAa;IAEvBF,OAAO,CAACG,WAAW,CAACF,KAAK,EAAE;MACzBG,OAAO,EAAE;IACX,CAAC,CAAC;IAEFJ,OAAO,CAACK,WAAW,CAACJ,KAAK,EAAEK,MAAM,CAACC,IAAI,CAACL,GAAG,CAAC,CAAC;IAC5CM,OAAO,CAACC,GAAG,CAAC,cAAc,EAAEP,GAAG,CAAC;EAClC,CAAC,CAAC;AACJ,CAAC,CAAC;AAEFQ,UAAU,CAAC,YAAW;EACpBb,UAAU,CAACc,KAAK,CAAC,CAAC;EAClBC,OAAO,CAACC,IAAI,CAAC,CAAC,CAAC;AACf,CAAC,EAAE,GAAG,CAAC;AAET,eAAeC,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}